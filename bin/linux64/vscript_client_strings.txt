__gmon_start__
_init
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
Plat_IsInDebugSession
WriteMiniDump
Plat_ExitProcess
g_pMemAlloc
__gxx_personality_v0
memset
strlen
memcpy
strchr
wcslen
wcschr
__cxa_guard_acquire
RandomFloat
RandomInt
__cxa_guard_release
__cxa_atexit
_ZTVN10__cxxabiv117__class_type_infoE
_ZTVN10__cxxabiv120__si_class_type_infoE
__stack_chk_fail
Plat_FloatTime
_Z6DevMsgPKcz
Error
Plat_MSTime
Warning
_Z10DevWarningPKcz
strtol
strtoll
strtoul
strtod
__sprintf_chk
memmove
strstr
toupper
tolower
__vsprintf_chk
__longjmp_chk
_setjmp
isxdigit
isalnum
isalpha
iscntrl
memcmp
strcmp
socket
__fdelt_chk
select
listen
accept
__printf_chk
strcpy
ThreadSleep
_ZNSs6assignEPKcm
_ZNSs6appendEmc
_ZSt18_Rb_tree_incrementPKSt18_Rb_tree_node_base
_ZNSs4_Rep20_S_empty_rep_storageE
_ZNSs4_Rep10_M_destroyERKSaIcE
_ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base
_ZNSs6assignERKSs
_ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_
_ZNSs4_Rep10_M_disposeERKSaIcE
__cxa_begin_catch
__cxa_rethrow
__cxa_end_catch
_ZSt20__throw_length_errorPKc
__strcpy_chk
_ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_
__pthread_key_create
malloc
__exp_finite
__pow_finite
__atan2_finite
__log10_finite
__log_finite
__acos_finite
__asin_finite
srand
ispunct
isspace
islower
isupper
isprint
strtok
__memcpy_chk
__snprintf_chk
__cxa_allocate_exception
__cxa_throw
__cxa_free_exception
__vsnprintf_chk
sscanf
__dynamic_cast
_Z6ConMsgPKcz
_ZTVN10__cxxabiv121__vmi_class_type_infoE
s_pInterfaceRegs
dlopen
dlerror
CommandLine
CreateInterface
dlclose
dlsym
getcwd
strnlen
strcasecmp
towupper
towlower
wcsncpy
__vswprintf_chk
strncat
wcsncat
mbstowcs
wcstombs
iconv_open
iconv
iconv_close
LOG_GENERAL
LoggingSystem_IsChannelEnabled
LoggingSystem_Log
chdir
iswalnum
iswspace
strtoull
iswalpha
__atan2f_finite
sincosf
__acosf_finite
__expf_finite
GetCPUInformation
RandomSeed
cbrtf
libtier0_client.so
libvstdlib_client.so
libm.so.6
libdl.so.2
libstdc++.so.6
libpthread.so.0
ld-linux-x86-64.so.2
abort
pthread_once
dl_iterate_phdr
pthread_mutex_unlock
pthread_mutex_lock
libc.so.6
_edata
__bss_start
GLIBC_2.2.5
GLIBC_2.15
GLIBC_2.14
GLIBC_2.4
GLIBC_2.3.4
GLIBC_2.11
CXXABI_1.3
GLIBCXX_3.4
fffff.
ffffff.
ffffff.
3@T]f
C8[A\]
AUATA
A\A]A^]
AWAVI
H[A\A]A^A_]
AUATA
A\A]A^]
AWAVAUA
t#L+e
H[A\A]A^A_]
AUATA
A\A]A^]
ffffff.
AUATL
[A\A]]
ffff.
AVAUL
[A\A]A^]
AVAUL
[A\A]A^]
AVAUL
[A\A]A^]
AWAVA
AUATI
}{D9u
[A\A]A^A_]
AVAUATL
 [A\A]A^]
AWAVAUL
[A\A]A^A_]
AWAVL
AUATSH
[A\A]A^A_]
fffff.
AWAVAUATSH
[A\A]A^A_]
AVAUATI
[A\A]A^]
[A\A]A^]
AUATSH
[A\A]]
[A\A]]
[A\A]]
AUATSH
[A\A]]
[A\A]]
[A\A]]
AWAVI
[A\A]A^A_]
[A\A]A^A_]
[A\A]]
[A\A]]
t	[A\]
AUATI
[A\A]]
AWAVAUATSH
[A\A]A^A_]
M;ox}Q
AWAVAUI
[A\A]A^A_]
([A\A]A^A_]
AWAVAUI
8[A\A]A^A_]
+{$Hc
[A\A]]
[A\A]]
[A\A]]
[A\A]]
Ic4$H
AWAVAUATSH
dH34%(
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATI
[A\A]A^A_]
AWAVAUATM
8[A\A]A^A_]
8[A\A]A^A_]
H9Hpt
AWAVA
8[A\A]A^A_]
8[A\A]A^A_]
AVAUATI
L;ppt
A\A]A^]
AUATI
L;opt
[A\A]]
AWAVI
AUATSH
[A\A]A^A_]
L;xpt
AUATI
[A\A]]
D+k$Mc
[A\A]]
[A\A]]
AUATI
[A\A]]
D+k$Mc
[A\A]]
[A\A]]
+S$Hc
AUATI
[A\A]]
D+k$Mc
[A\A]]
[A\A]]
AUATI
[A\A]]
D+k$Mc
[A\A]]
[A\A]]
+{$Hc
+{$Hc
AUATI
[A\A]A^]
[A\A]A^]
AVAUATL
[A\A]A^]
AWAVI
[A\A]A^A_]
 M9t$
AWAVAUI
[A\A]A^A_]
t(HcO
[A\A]]
AUATL
[A\A]]
AUATL
[A\A]]
AWAVAUA
[A\A]A^A_]
[A\A]A^A_]
tNH9P
S@H9P
[A\A]A^A_]
AW-VUUUAV
t"H;2H
([A\A]A^A_]
AUATI
-VUUU
A#D$xH
[A\A]A^]
[A\A]A^]
AWAVAUATA
[A\A]A^A_]
AWAVI
AUATSH
[A\A]A^A_]
AVAUATI
 [A\A]A^]
M;l$Xr
M;l$pr
M;l$Hr
M;l$`r
A+E$H
A+E$H
AUATI
([A\A]]
A+E$H
H;sHr
H;s`r
([A\A]]
A+E$H
A+U$Hc
A+U$Hc
A+E$H
A+E$H
AUATI
[A\A]]
AVAUATI
H;sHr
H;s`r
H;sxr
 [A\A]A^]
 [A\A]A^]
A+E$H
A+E$H
AWAVAUI
([A\A]A^A_]
([A\A]A^A_]
AWAVL
[A\A]A^A_]
AWAVAUATI
[A\A]A^A_]
E+o$Mc
A+W$Hc
A+G$H
A+W$Hc
E+w$Mc
A+G$H
AWAVL
[A\A]A^A_]
G8I9E8
AWAVAUATI
([A\A]A^A_]
D+k$Mc
I9D$XI
MD$XI
H;sHr
H;s`r
([A\A]A^A_]
AWAVAUATL
8[A\A]A^A_]
[A\A]A^A_]
AWAVH
8[A\A]A^A_]
S8H9S@
[A\A]A^A_]
AWAVL
H[A\A]A^A_]
[A\A]A^A_]
AVAUATI
P[A\A]A^]
P[A\A]A^]
D+k$Mc
+S$Hc
D+C$Mc
AWAVL
H[A\A]A^A_]
[A\A]A^A_]
AUATL
([A\A]]
([A\A]]
fffff.
[A\A]]
[A\A]]
AUATSH
[A\A]A^]
AWAVI
AUATI
[A\A]A^A_]
[A\A]A^A_]
ffffff.
ffffff.
ffffff.
ffffff.
AVAUI
[A\A]A^]
AUATI
[A\A]]
[A\A]]
AUATI
GpH+GxH
S8H9S@vkH
([A\A]]
AWAVAUATSH
GpH+GxH
([A\A]A^A_]
ffffff.
ffffff.
]H+Gx
AVAUATI
GpH+GxH9
[A\A]A^]
A\A]A^]
ffff.
AUATSH
[A\A]]
ffff.
AVAUATSH
GpH+GxH
 [A\A]A^]
[A\A]A^]
ffff.
4$A\]
AVAUATI
[A\A]A^]
[A\A]A^]
[A\A]]
[A\A]]
fffff.
ffffff.
[A\A]]
[A\A]]
AVAUATSH
[A\A]A^]
A\A]A^]
[A\A]A^]
AUATSH
GpH+GxH
8[A\A]]
8[A\A]]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
fffff.
AUATSH
[A\A]]
A\A]]
[A\A]]
[A\A]]
AUATSH
[A\A]]
[A\A]]
AVAUATSH
GpH+GxH
H[A\A]A^A_]
L;c@H
L;k8sJH
L;k8r
AUATI
GpH+GxH
[A\A]]
[A\A]]
A\A]]
AVAUATSH
GpH+GxH
L;s@v0M
C0t H
[A\A]A^]
L;c8sBL
L;c8r
[A\A]A^]
A\A]A^]
I;\$8sEH
I;\$8r
AVAUATSH
GpH+GxH
[A\A]A^]
[A\A]A^]
ffffff.
AVAUATI
[A\A]A^]
L;kHsBL
L;kHr
AWAVAUI
[A\A]A^A_]
([A\A]A^A_]
AUATI
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
8[A\A]A^A_]
[A\A]]
A\A]]
0[A\A]A^]
0[A\A]A^]
ffffff.
H9ZXv3H
[A\A]]
[A\A]]
[A\A]]
[A\A]]
AVAUH
0[A\A]A^]
0[A\A]A^]
0[A\]
0[A\]
 [A\]
 [A\]
 [A\]
ffffff.
ffffff.
AVAUATSH
`[A\A]A^]
`[A\A]A^]
ffffff.
AWAVAUI
([A\A]A^A_]
([A\A]A^A_]
ffffff.
AWAVL
AUATI
8[A\A]A^A_]
8[A\A]A^A_]
AVAUI
8[A\A]A^A_]
8[A\A]A^A_]
8[A\A]A^A_]
AWAVI
H9S`w
([A\A]A^A_]
([A\A]A^A_]
AWAVAUI
t$XL;s`
L;{XsRH
L;{Xr
KPt#I
t$@L;sHv?M
[A\A]A^A_]
h[A\A]A^A_]
h[A\A]A^A_]
L;s`v0M
KPt#I
L;sxv0M
Kht#I
L;{Xs
L;{ps
AUATSH
A\A]]
ffff.
AUATSH
[A\A]]
[A\A]]
AUATH
[A\A]]
[A\A]]
ffffff.
ffffff.
ffff.
ffffff.
ffffff.
AVAUATI
A\A]A^A_]
AWAVI
[A\A]A^A_]
ffff.
AUATL
H[A\A]]
H[A\A]]
AVAUATS1
[A\A]A^A_]
AVAUATS1
[A\A]A^A_]
ffff.
fffff.
 [A\]
 [A\]
AUATI
([A\A]]
([A\A]]
AWAVAUATI
([A\A]A^A_]
L;k@H
([A\A]A^A_]
L;c8sBL
L;c8r
AVAUATSH
L;s@v0M
 [A\A]A^]
 [A\A]A^]
L;c8sBL
L;c8r
ffff.
AWAVAUATSH
D$8I9
([A\A]A^A_]
([A\A]A^A_]
([A\A]A^A_]
|$0L)
AUATI
([A\A]]
([A\A]]
fffff.
AUATSH
([A\A]]
AUATSH
([A\A]]
AUATL
A\A]]
AWAVI
[A\A]A^A_]
A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATI
[A\A]A^A_]
L;k8sBL
L;k8r
ffff.
AWAVI
AUATSH
[A\A]A^A_]
I9\$@
H;Y8}
|$@I9
L9cx~nH
L9`8~
I;D$8
AWAVH
h[A\A]A^A_]
M;u8}BL
H9X8~
h[A\A]A^A_]
AVAUATSH
[A\A]A^]
fffff.
[A\A]]
AUATSH
L;kHsNM
L;kHr
L;k`sNM
L;k`r
L;cxsFL
L;cxr
[A\A]]
AUATSH
L;cxsBL
L;cxH
L;k`s:M
L;kHs:M
[A\A]]
fffff.
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
SHH9SP
[A\A]A^A_]
S`H9Sh
AVAUL
[A\A]A^]
[A\A]A^]
AVAUL
[A\A]A^]
[A\A]A^]
AVAUL
[A\A]A^]
[A\A]A^]
AVAUATL
[A\A]A^]
AUATSH
[A\A]]
AVAUATL
[A\A]A^]
fffff.
AWAVAUI
L;{Pv)M
 H;CH
L;{hv)M
 H;C`
Kpt!I
x[A\A]A^A_]
L;sxsBL
L;sxr
[A\A]]
[A\A]]
AWAVE
[A\A]A^A_]
AWAVAUI
t"H=6
H[A\A]A^A_]
AWAVAUATSH
h[A\A]A^A_]
,uef.
AWAVAUATSH
[A\A]A^A_]
tDH=6
AWAVAUL
H[A\A]A^A_]
=t{H=
AWAVAUATSH
([A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
t'H=2
8[A\A]A^A_]
AWAVAUATL
[A\A]A^A_]
AWAVAUATL
[A\A]A^A_]
AWAVAUATL
[A\A]A^A_]
AWAVL
AUATSH
;|uif
[A\A]A^A_]
AWAVAUL
t-H=7
([A\A]A^A_]
AVAUATSH
8[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATA
A\A]A^A_]
,uef.
AWAVAUATSH
[A\A]A^A_]
D$PI9D$Xv.I
L$`E1
T$PE1
D$hM)
D$hH)
D$PE1
D$hI9D$pv2I
AWAVAUATL
;,u}H
T$`E1
D$hH)
t H=6
D$PE1
h[A\A]A^A_]
AWAVAUATL
t$H=6
X[A\A]A^A_]
AWAVAUL
o ATL
t$H=6
8[A\A]A^A_]
AWAVAUATL
T$HE1
([A\A]A^A_]
fffff.
 [A\]
 [A\]
 [A\]
 [A\]
AUATE1
H[A\A]A^A_]
H[A\A]A^A_]
AWAVAUATI
8[A\A]A^A_]
8[A\A]A^A_]
 [A\]
 [A\]
 [A\]
 [A\]
AUATSH
[A\A]]
AUATI
S(H9S0v-H
[A\A]]
AVAUI
0[A\A]A^]
AUATSH
8[A\A]]
8[A\A]]
AUATSH
H9C8s
[A\A]]
[A\A]]
P[A\]
AWAVI
AUATSH
[A\A]A^A_]
AVAUATI
[A\A]A^]
AUATL
[A\A]]
AUATI
[A\A]]
AWAVAUATI
H;Ch|
H;Cx|
(H;KH|
[A\A]A^A_]
AVAUATSH
[A\A]A^]
AVAUI
([A\A]A^A_]
A\A]A^]
AVAUATE1
L9ch~FL
L9cx~FL
(L9cH~BL
[A\A]]
[A\A]]
AUATSH
[A\A]A^]
AVAUATI
8[A\A]A^A_]
H[A\A]A^A_]
H[A\A]A^A_]
t1<*tH
AUATSH
8[A\A]]
8[A\A]]
AVAUATA
WpI9Wx
WpI9Wx
H[A\A]A^A_]
WpI9Wx
WpI9Wx
WpI9Wx
WpI9Wx
WpI9Wx
WpI9Wx
WpI9Wx
WpI9Wx
WpI9Wx
WpI9Wx
WpI9Wx
WpI9Wx
WpI9Wx
WpI9Wxv4I
fffff.
AWAVI
[A\A]A^A_]
ffff.
AVAUATSH
SpH9Sx
SpH9Sx
SpH9Sx
SpH9Sx
SpH;Sx
SpH9Sxw
[A\A]A^]
[A\A]A^]
t9H9Sxw
AVAUA
S0[A\A]A^]
[A\A]A^]
AUATL
[A\A]]
[A\A]]
<=t#<>
<*uwH
fffff.
[A\A]A^]
L9cHw
L9c`w
s0[A\A]]
L9cXw
L9cpw
[A\A]]
I9\$Xw
[A\A]]
AVAUATI
A\A]A^]
[A\A]A^]
AUATSH
L9cHw
L;c`r
A\A]]
[A\A]]
AUATSH
L9cXw
L;cpr
A\A]]
[A\A]]
AUATI
I9\$Xw
A\A]]
[A\A]]
I9\$(H
AUATI
[A\A]]
[A\A]]
AWAVAUATI
L+nxH
L;kPH
L;sHsBL
L;sHr
|$XH9Shw
([A\A]A^A_]
[A\A]A^A_]
AWAVAUATI
S`H9ShvsH
f+PHf
x[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVI
AUATSH
S8H9S@
[A\A]A^A_]
~6H;r
[A\A]A^]
[A\A]A^]
A\A]A^]
[A\A]A^A_]
TRAPATL
[A\A]A^A_]
TRAPL
TRAPL
TRAPL
TRAPL
TRAPL
}zLke
TRAPL
TRAPL
TRAPL
TRAPL
RIQSSH
A\A]A^]
LIATA\A]A^]
AWAVL
[A\A]A^A_]
TRAPL
TRAPL
TRAPL
TRAPL
TRAPL
TRAPL
TRAPL
TRAPL
TRAPL
AUATSH
[A\A]]
L9cHw
L9c`w
A\A]]
AWAVAUI
A\A]A^A_]
[A\A]A^A_]
AVAUATSH
[A\A]A^]
L9kHw
L9k`w
L9kxw
A\A]A^]
AWAVI
AUATSH
[A\A]A^A_]
A\A]A^A_]
AUATI
L9kHw
L9k`w
[A\A]]
[A\A]]
AWAVI
AUATI
[A\A]A^A_]
AWAVL
AUATI
L9kHw
L9k`w
L9kxw
([A\A]A^A_]
([A\A]A^A_]
AWAVL
[A\A]A^A_]
[A\A]A^A_]
AVAUI
RIQSSH
[A\A]A^A_]
LIATL
I;\$8sHH
I;\$8I
I;\$8sHH
I;\$8I
I;\$XsHH
I;\$XI
I;\$XsHH
I;\$XI
L;cpsBL
L;cpH
L;cXsBL
L;cXH
L;cpsBL
L;cpH
L;cXsBL
L;cXH
L;c`sBL
L;c`H
L;cHsBL
L;cHH
L;c`sBL
L;c`H
L;cHsBL
L;cHH
I;\$8sEH
I;\$8r
I;\$XsEH
I;\$Xr
I;\$HsEH
I;\$Hr
I;\$XsEH
I;\$Xr
#[A\]
#[A\]
AUATM
(H9pH
[A\A]A^A_]
AWAVAUE1
 <YwA
?|uBH
[A\A]A^A_]
[A\A]A^A_]
AWAVAUI
H[A\A]A^A_]
[A\A]A^A_]
fffff.
 [A\]
 [A\]
@t%[A\]
@ A\]
t#~1= 
[A\A]]
AUATSH
~0[A\A]A^]
A]A^]
[A\A]A^]
AVAUATI
[A\A]A^]
[A\A]A^]
fffff.
AVAUATE1
[A\A]A^A_]
 [A\]
$I;D$
ti~lfH
fffff.
AUATSH
H#P0H
[A\A]]
AVAUI
t/L9{(u
[A\A]A^A_]
{(r2f
H#F0H
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AUATI
[A\A]]
AUATL
[A\A]]
fffff.
tWH9H
fffff.
AWAVI
AUATI
t_H;P
[A\A]A^A_]
(H;K@tfH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AVAUATSH
[A\A]A^A_]
tGH9H
AVAUI
(M9uH
[A\A]A^]
fffff.
AUATSH
(M;fH}UL
M;fH|
A\A]A^]
AUATSH
(M9fH~UL
A\A]A^]
AUATSH
[A\A]A^]
AUATSH
L;c`sBL
L;c`H
L;cHsBL
L;cHH
[A\A]]
fffff.
I;]p|FL
[A\A]]
AUATI
[A\A]]
[A\A]]
AWAVI
AUATI
H;WPH
[A\A]A^A_]
L;kHs
fffff.
fffff.
[A\A]]
AUATSH
A\A]A^]
A\A]A^]
A\A]A^]
fffff.
[A\A]A^]
AWAVAUATSH
L;sPH
I;\$H
[A\A]A^A_]
[A\A]]
[A\A]]
AUATS~}H
[A\A]A^]
fffff.
fffff.
AWAVAUATI
M;wHsFL
M;wHr
HcV,H
CxHcV
Ic4$A
Ic<$H
Ic4$A
Ic<$H
HcP(H
Ic<$Hc@(H)E
Ic<$A
D$8I9D$@
Mc$$H
Ic4$A
Ic4$H
Ic4$A
s@Ic<$H
s@Ic<$H
s@Ic<$H
Ic4$H
CxMc,$L
Ic4$A
Ic4$H
sxHc@4H
Ic4$H
SxIc4$E
CxIc<$H
Ic4$H
[A\A]A^A_]
M;wHsFL
M;wHr
H;Cp|
HcH(H
SxIc4$H
Mc,$H
Ic<$I
AVAUI
H[A\A]A^A_]
H[A\A]A^A_]
H[A\A]A^A_]
AWAVAUATI
8[A\A]A^A_]
8[A\A]A^A_]
AUATSH
[A\A]]
AWAVI
([A\A]A^A_]
([A\A]A^A_]
AVAUATI
_@I9Wh
S`f+PHf
[A\A]A^A_]
L;cPH
L;kHsBL
L;kHr
AWAVAUI
HcP8L9
KxHcP,L
x@LcH4H
Hcp0H
L;sp|
([A\A]A^A_]
AVAUL
[A\A]A^]
[A\A]A^]
[A\A]]
[A\A]]
[A\A]]
AWAVI
([A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
 [A\]
AVAUATI
 [A\A]A^]
 [A\A]A^]
 [A\A]A^]
AWAVH
[A\A]A^A_]
[A\A]A^A_]
A\A]A^A_]
fffff.
fffff.
AVAUL
[A\A]A^]
[A\A]A^]
[A\A]]
[A\A]]
[A\A]]
[A\A]A^A_]
U@H9r
A\A]A^A_]
xbH;Q8}\H
[A\A]A^A_]
AWAVAUI
H[A\A]A^A_]
SXH9S`
sXt(H
D$@H9S`
t$@L9
HPH9S`
fffff.
AVAUM
[A\A]A^A_]
8[A\A]A^A_]
S@H9J
[A\A]A^A_]
fffff.
AWAVAUATI
[A\A]A^A_]
fffff.
AWAVAUI
X[A\A]A^A_]
c8M;g@
I;W8sRH
I;W8r
O0t!H
X[A\A]A^A_]
AWAVAUI
[A\A]A^A_]
AWAVI
[A\A]A^A_]
[A\A]A^A_]
[A\A]]
I;\$HsEH
I;\$Hr
[A\A]]
[A\A]]
[A\A]]
 [A\A]A^]
AWAVAUATSH
[A\A]A^A_]
0[A\]
0[A\]
AUATH
[A\A]]
AWAVI
AUATSH
[A\A]A^A_]
fffff.
fffff.
fffff.
AUATI
Hcs I
[A\A]]
fffff.
AWAVI
AUATSH
[A\A]A^A_]
fffff.
AUATL
[A\A]]
AVAUATI
[A\A]A^]
AUATL
[A\A]]
AUATI
[A\A]]
AUATL
[A\A]]
AWAVL
toA9W L
8[A\A]A^A_]
8[A\A]A^A_]
AVAUATI
 [A\A]A^]
 [A\A]A^]
A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATSH
A\A]A^A_]
AUATSH
vQf=sr
v.f=di
f=siu
([A\A]]
f=rbu
f=spf
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
A9G }
([A\A]A^A_]
([A\A]A^A_]
AVAUL
[A\A]A^A_]
([A\A]A^A_]
AWAVAUATI
[A\A]A^A_]
[A\A]A^A_]
([A\A]A^A_]
A\A]A^A_]A
[A\A]A^A_]
AWAVAUATSH
h[A\A]A^A_]
ffffff.
fffff.
fffff.
ffff.
[A\A]]
[A\A]]
AUATH
[A\A]]
[A\A]]
ffffff.
AUATI
[A\A]]
[A\A]]
AWAVI
AUATI
[A\A]A^A_]
ffff.
AUATL
[A\A]]
A\A]]
ffffff.
AUATSH
[A\A]]
[A\A]]
AWAVAUATSH
[A\A]A^A_]
AVAUATSH
A\A]A^]
[A\A]A^]
AVAUATI
8[A\A]A^A_]
8[A\A]A^A_]
8[A\A]A^A_]
8[A\A]A^A_]
t.L9u
[A\A]A^A_]
AVAUI
[A\A]A^]
[A\A]A^]
AVAUATI
[A\A]A^A_]
[A\A]A^A_]
A\A]A^]
H;w@}
AUATH
[A\A]]
[A\A]]
[A\A]]
[A\A]A^A_]
[A\A]A^A_]
 [A\]
$[A\]
A\A]A^]
AVAUH
[A\A]A^]
A\A]A^]
ffff.
[A\A]]
fffff.
AUATE1
dH3<%(
[A\A]A^A_]
AUATSH
[A\A]]
[A\A]]
AWAVI
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AUATI
[A\A]A^A_]
AWAVI
AUATSH
[A\A]A^A_]
AUATI
[A\A]]
[A\A]]
AWAVI
[A\A]A^A_]
[A\A]A^A_]
fffff.
fffff.
<$A\]
AUATL
[A\A]]
AVAUL
[A\A]A^]
[A\A]A^]
AWAVAUL
[A\A]A^A_]
fffff.
AVAUI
?A\A]A^A_]
AUATI
?A\A]A^A_]
AUATI
?A\A]A^]
AUATI
?A\A]A^A_]
fffff.
AUATI
?A\A]A^A_]
AWAVI
?A\A]A^A_]
AVAUI
?A\A]A^A_]
AUATI
?A\A]A^A_]
fffff.
AUATI
?A\A]A^]
AUATI
?A\A]A^A_]
AUATI
?A\A]A^A_]
fffff.
AUATI
?A\A]A^A_]
fffff.
AUATI
?A\A]A^A_]
AUATI
?A\A]A^A_]
4 A\]
fffff.
AWAVL
u&Hcu
[A\A]A^A_]
[A\A]A^A_]
[A\A]]
fffff.
[A\A]]
[A\A]A^A_]
fffff.
AWAVL
[A\A]A^A_]
[A\A]]
dH3<%(
AVAUH
[A\A]A^]
AVAUL
[A\A]A^]
fffff.
AUATI
[A\A]]
[A\A]]
[A\A]]
fffff.
AUATSH
[A\A]]
AUATI
[A\A]]
fffff.
fffff.
<$*tAL
X[A\A]]
t|y|L
[A\A]A^A_]
[A\A]A^A_]
G u*H
fffff.
	w(UH
fffff.
AUATSH
H[A\A]]
AVAUATA
CXt;H
@[A\A]A^]
AVAUATSH
HcWPH
[A\A]A^A_]
fffff.
ffff.
AUATSH
[A\A]]
[A\A]]
AUATI
[A\A]]
[A\A]]
fffff.
AWAVAUI
8[A\A]A^A_]
fffff.
AVAUI
tWA9]
~)A;]
[A\A]A^A_]
[A\A]A^A_]
fffff.
{pH97tpH
AVAUATI
P[A\A]A^]
t4[A\A]A^]
A\A]A^]
[A\A]A^A_]
ffff.
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
fffff.
AWAVAUATI
x[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUI
[A\A]A^A_]
HcSPH
 [A\A]A^]
fffff.
fffff.
AUATA
A\A]A^]
AUATA
A\A]A^]
ffff.
[A\A]]
[A\A]]
AUATSH
[A\A]]
ffff.
AUATL
[A\A]]
fffff.
AUATSH
dH34%(
[A\A]]
[A\A]A^]
A\A]A^]
fffff.
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
vP<_tL
AVAUATS
[A\A]A^]
ffff.
ffff.
[A\A]]
fffff.
AVAUATI
A\A]A^]
A\A]A^]
ffff.
<XueH
<Xu-H
AUATSH
A\A]]
A\A]]
ffff.
AWAVAUI
[A\A]A^A_]
AVAUATD
[A\A]A^]
A\A]A^]
ffff.
ffff.
AUATI
[A\A]]
AUATI
[A\A]]
[A\A]]
[A\A]]
[A\A]]
[A\A]A^]
AWAVI
[A\A]A^A_]
AWAVI
[A\A]A^A_]
AVAUATA
p[A\A]A^]
AWAVL
AUATSH
[A\A]A^A_]
 [A\A]A^]
([A\A]A^A_]
[A\A]A^A_]
ffffff.
 [A\A]A^]
([A\A]A^A_]
AUATLc
[A\A]A^A_]
AWAVAUI
([A\A]A^A_]
AVAUATI
[A\A]A^]
fffff.
[A\A]]
[A\A]]
/t7I9
$<.tO
[A\A]]
[A\A]]
AUATSH
[A\A]]
dH3<%(
[A\A]]
<\tz</tv1
</tS<\tOH
A\A]]
A\A]]
AVAUA
A\A]A^]
A\A]A^]
AWAVAUI
t/<.u
</t!f
[A\A]A^A_]
[A\A]A^A_]
AVAUATSH
[A\A]A^]
,#[A\A]A^]
ffff.
[A\A]]
AUATI
[A\A]A^A_]
AWAVAUATSH
<\u&H
[A\A]A^A_]
[A\A]A^A_]
A\A]A^A_]
[A\A]A^A_]
ffffff.
AVAUATI
8[A\A]A^A_]
[A\A]A^A_]
ffff.
[A\A]]
ffffff.
fffff.
[A\A]A^]
A\A]A^]
AWAVAUI
dH3<%(
[A\A]A^A_]
AWAVAUI
t)< ~
dH3<%(
[A\A]A^A_]
fffff.
AWAVAUATSH
HcM te
8[A\A]A^A_]
8[A\A]A^A_]
A\A]A^A_]
AUATSH
[A\A]]
[A\A]]
fffff.
[A\A]]
[A\A]]
[A\A]]
[A\A]]
[A\A]]
[A\A]]
t	D; u
ffff.
AWAVAUATA
tcA:]
[A\A]A^A_]
ffffff.
ffff.
fffff.
AVAUD
ATSA9
"E:#uIA
[A\A]A^]
A\A]A^]
fffff.
AWAVAUATSH
dH3<%(
X[A\A]A^A_]
AWAVAUATSH
~2D9e
[A\A]A^A_]
]tG9E
AWAVLc
[A\A]A^A_]
[A\A]A^A_]
AUATI
<$.tlL
dH34%(
[A\A]]
AWAVL
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUA
8[A\A]A^A_]
8[A\A]A^A_]
AWAVAUA
([A\A]A^A_]
A\A]A^A_]
ffff.
AWAVAUA
8[A\A]A^A_]
AWAVAUATSH
+S$Hc
+S$Hc
+S$Hc
+S$Hc
+S$Hc
[A\A]A^A_]
+S$Hc
+S$Hc
+S$Hc
AWAVAUATSD
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSD
[A\A]A^A_]
[A\A]A^A_]
[A\A]]
AUATA
[A\A]]
[A\A]]
AWAVI
HA\A]A^A_]
8[A\A]A^A_]
[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATI
8[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUI
8[A\A]A^A_]
HA\A]A^A_]
[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATI
8[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
A\A]A^A_]
[A\A]A^A_]
8[A\A]A^A_]
fffff.
ffffff.
AVAUATSH
8[A\A]A^A_]
HA\A]A^A_]
[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATI
8[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
A\A]A^A_]
[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATI
8[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUI
8[A\A]A^A_]
HA\A]A^A_]
[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATI
8[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATI
8[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUI
8[A\A]A^A_]
HA\A]A^A_]
[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATI
8[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
A\A]A^A_]
[A\A]A^A_]
8[A\A]A^A_]
AWAVI
AUATSH
X[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUI
X[A\A]A^A_]
A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATI
XA\A]A^A_]
X[A\A]A^A_]
[A\A]A^A_]
X[A\A]A^A_]
AWAVAUATI
H[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVI
AUATI
[A\A]A^A_]
AVAUATSH
[A\A]A^A_]
AWAVAUATI
h[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUI
h[A\A]A^A_]
X[A\A]A^A_]
[A\A]A^A_]
h[A\A]A^A_]
ffff.
AWAVAUI
A\A]A^A_]
h[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATI
H[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVI
AUATI
[A\A]A^A_]
AVAUATSH
[A\A]A^A_]
AUATL
[A\A]]
[A\A]]
AUATL
[A\A]]
[A\A]]
AVAUATE1
[A\A]A^]
AVAUATE1
[A\A]A^]
fffff.
AVAUATA
[A\A]A^]
AVAUATA
[A\A]A^]
ffffff.
[A\A]A^A_]
[A\A]A^A_]
ffff.
AVAUA
A;G ~
[A\A]A^A_]
[A\A]]
fffff.
<19{ |.
AVAUATA
[A\A]A^]
A+u$Hc
[A\A]A^]
fffff.
+S$Hc
AUATSH
[A\A]]
fffff.
AUATSH
[A\A]]
[A\A]]
AUATI
+s$Ic
[A\A]]
AVAUATI
A+D$$H
[A\A]A^A_]
A\A]A^A_]
E+D$$Mc
[A\A]]
[A\A]]
AWAVAUATSH
+s$Hc
([A\A]A^A_]
([A\A]A^A_]
A\A]A^A_]
+S$Hc
+S$Hc
AVAUI
A\A]A^]
[A\A]A^]
[A\A]A^]
AWAVI
AUATSH
E+F$Mc
[A\A]A^A_]
AWAVAUI
[A\A]A^A_]
[A\A]A^A_]
AVAUATSH
G A9G
8[A\A]A^A_]
8[A\A]A^A_]
A+W$Hc
[A\A]A^A_]
E+G$Mc
E+O$Mc
A+G$H
[A\A]A^A_]
E+O$Mc
E+G$Mc
E+G$Mc
A+G$Lc
E+G$Mc
E+O$Mc
A+G$Lc
AUATI
+S$Hc
[A\A]]
$+s$Hc
AWAVI
AUATA
[A\A]A^A_]
A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVH
AUATI
[A\A]A^A_]
A+L$$Hc
fffff.
AWAVE
[A\A]A^A_]
+S$Hc
+S$Hc
"t%L;}
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
fffff.
c [A\]
c [A\]
AUATS
[A\A]]
A+|$$Hc
A;t$ A
[A\A]]
fffff.
AVAUI
A\A]A^]
[A\A]A^]
[A\A]A^]
fffff.
AVAUA
+S$Hc
A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
+W$Hc
+S$Hc
AVAUATI
7+W$Hc
A+G$H
A;w A
7A+W$Hc
A+G$H
A;w A
A+G$H
A;w A
7A+W$Hc
A+G$H
A;w A
([A\A]A^A_]
[A\A]A^A_]
7A+W$Hc
A+G$H
A;w A
A+G$H
A;w A
A;\$ A
9w UH
fffff.
fffff.
AWAVAUATSH
[A\A]A^A_]
+K$Lc
[A\A]A^A_]
AWAVAUATI
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
7A+W$Hc
A+G$H
A;w A
A+G$H
A;w A
[A\A]A^A_]
7A+W$Hc
A+G$H
A;w A
A+G$H
A;w A
7A+W$Hc
A+G$H
A;w A
A+G$H
A;w A
GHHcv
4$A\]
[A\A]A^]
+C$9C
+C$;C
AVAUI
[A\A]A^]
AVAUI
[A\A]A^]
fffff.
fffff.
AUATSH
[A\A]]
[A\A]]
[A\A]]
[A\A]]
AWAVAUI
[A\A]A^A_]
[A\A]]
	[A\]
[A\A]]
[A\A]]
[A\A]]
fffff.
fffff.
[A\A]]
fffff.
[A\A]]
fffff.
([A\A]]
AVAUATI
[A\A]A^]
A\A]A^]
AVAUATA
[A\A]A^]
fffff.
AWAVAUI
[A\A]A^A_]
AWAVI
AUATSH
[A\A]A^A_]
 [A\]
A\A]A^]
A\A]A^]
[A\A]A^]
fffff.
fffff.
fffff.
AUATI
[A\A]]
fffff.
AWAVAUATSH
[A\A]A^A_]
fffff.
AVAUATE1
x[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
fffff.
AWAVAUATSH
[A\A]A^A_]
tPHcE
x[A\A]A^A_]
[A\A]A^A_]
fffff.
AVAUAT
A\A]A^]
A\A]A^]
A\A]A^]
ffff.
ffff.
[A\A]A^A_]
ffff.
ffffff.
 [A\]
fffff.
fffff.
fffff.
 [A\]
 [A\]
fffff.
8[A\A]]
[A\A]]
C,[A\]
C,[A\]
AUATL
[A\A]]
fffff.
 [A\A]A^]
 [A\]
 [A\]
ffffff.
([A\A]]
fffff.
fffff.
 [A\A]]
fffff.
fffff.
ffff.
ffff.
AWAVAUATSH
h[A\A]A^A_]
h[A\A]A^A_]
ffffff.
0[A\]
C,[A\]
C,[A\A]]
ffff.
0[A\]
[A\A]A^]
ffffff.
[A\A]]
fffff.
@[A\]
0[A\]
ffff.
AVAUL
0[A\A]A^]
AVAUL
0[A\A]A^]
0[A\A]A^A_]
ffffff.
 [A\A]A^]
fffff.
8[A\A]A^A_]
0[A\A]A^A_]
0[A\A]A^A_]
0[A\A]A^A_]
fffff.
8[A\A]]
8[A\A]]
8[A\A]]
8[A\A]]
[A\A]]
[A\A]]
[A\A]]
[A\A]]
&YA1[]
fffff.
H[A\A]A^A_]
ffff.
[A\A]A^]
AWAVAUATI
[A\A]A^A_]
[A\A]]
AVAUATSHc
dH3<%(
[A\A]A^]
8[A\A]A^A_]
ffffff.
fffff.
fffff.
t$@A\]
AWAVL
[A\A]A^A_]
fffff.
AWAVL
[A\A]A^A_]
AWAVL
H[A\A]A^A_]
fffff.
`[A\]
p[A\]
[A\A]A^A_]
`[A\]
p[A\]
AWAVAUATI
x[A\A]A^A_]
fffff.
AWAVL
[A\A]A^A_]
ffff.
ffffff.
fffff.
AWAVL
[A\A]A^A_]
AVAUATSH
 [A\A]A^]
ffff.
ffff.
ffffff.
AWAVL
H[A\A]A^A_]
AWAVAUA
A\A]A^A_]A
AWAVAUA
A\A]A^A_]A
AWAVAUA
A\A]A^A_]A
AUATL
h[A\A]]
8[A\A]]
ffff.
ffff.
ffff.
ffffff.
ffff.
0[A\]
ffff.
fffff.
ffff.
fffff.
ffffff.
ffff.
[A\A]]
0[A\]
ffff.
 [A\]
 [A\]
ffff.
AWAVL
([A\A]A^A_]
H[A\A]]
X[A\A]A^]
H[A\A]]
AWAVL
[A\A]A^A_]
fffff.
AWAVAUATA
H[A\A]A^A_]
ffffff.
ffffff.
ffffff.
fffff.
ffff.
AWAVI
AUATI
[A\A]A^A_]
AVAUATI
<Rt<<Pt`<S
H[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AVAUATI
[]A\A]A^A_
fffff.
AUATUSH
[]A\A]A^A_
[]A\A]
AUATI
[]A\A]
[]A\A]
AWAVAUI
[]A\A]A^A_
fffff.
ffffff.
AWAVI
AVAUI
ffffff.
AWAVAUATSH
[A\A]A^A_]
AWAVI
([]A\A]A^A_
[]A\A]A^A_
 []A\
 []A\
ATUSH
[]A\A]A^
AUATI
T$8H)
[]A\A]A^A_
[]A\A]A^A_
ffffff.
AVAUI
[]A\A]A^
AVAUATUSH
ttIcG
8[]A\A]A^A_
[]A\A]A^A_
fffff.
AWAVE1
H[]A\A]A^A_
AWAVAUATI
X[]A\A]A^A_
D$@L9
D$8L9
X[]A\A]A^A_
D$@I9
D$8I9
AWAVAUATUSH
X[]A\A]A^A_
[]A\A]A^A_
D$ H9
^ t+H
fffff.
t$H9h
H9*tgH
ffff.
AVAUATI
0[]A\A]A^
vscript
Generate a random floating point number within a range, inclusive
Generate a random integer within a range, inclusive
RandomFloat
RandomInt
VScriptManager009
10IAppSystem
14IScriptManager
23CSplitScreenAddedConVar
14CBaseAppSystemI14IScriptManagerE
15CTier0AppSystemI14IScriptManagerE
15CTier1AppSystemI14IScriptManagerLi0EE
14CScriptManager
FLOAT
INTEGER
TABLE
ARRAY
NATIVECLOSURE
USERDATA
GENERATOR
THREAD
USERPOINTER
CLASS
INSTANCE
WEAKREF
<unknown>
Squirrel
null vector
Vector
unnamed
%x%x%llx_%s
function 
<unnamed>
%s [%d]
Vector argument expected
Accessed null instance
Internal error
handle
RegisterFunctionDocumentation
(vector : (%f, %f, %f))
%f %f %f))
(instance : 0x%p)
developer
CUtlFixedMemory overflow!
constructor
_tostring
IsValid
CUtlRBTree overflow!
Incompatible script version
GetFunctionSignature
VSquirrel_OnCreateScope
VSquirrel_OnReleaseScope
_typeof
_nexti
ToKVString
Length
LengthSqr
Length2D
Length2DSqr
Cross
Script running too long, terminating
GenerateUniqueKey: buffer too small
NULL instance passed to vscript!
Invalid scope handed to script VM
Script function returned unsupported type
Callstack mismatch in VScript/Squirrel!
FmtStrVSNPrintf truncated to %d without QUIET_TRUNCATION specified!
CUtlLinkedList overflow! (exhausted index range)
CUtlLinkedList overflow! (exhausted memory allocator)
Save load of generators not well tested. caveat emptor
Failed to restore a Squirrel object of type %s
Failed to read Squirrel table entry %s
13SQCollectable
16CSQStateIterator
9IScriptVM
8CFmtStrNILi256ELb0EE
11CSquirrelVM
ZN11CSquirrelVM9DumpStateEvE9CIterator
wrong argument type, expected '%s' got '%.50s'
not enough params in the stack
the object is not a nativeclosure
the object is not a class instance
rawset works only on array/table/class and instance
rawget works only on array/table/instance and class
clear only works on table and array
only generators can be resumed
cannot resume a vm that is not running any code
the type doesn't have a default delegate
unexpected type %s
invalid base type
invalid param type
ivalid type
ivalid type, expected table
invalid object type
the object is not a class
the class is locked
invalid type tag
null is not a valid key
null key
delagate cycle
wrong type
the index doesn't exist
the object is not a closure
negative size
io error
invalid stream
invalid free var index
wrong index
the object must be a weakref
cannot iterate a generator
native closure expected
invalid typemask
the target is not a closure
invalid environment
unnamedbuffer
invalid param
unknown
locals
running
suspended
internal VM error
top() on a empty array
assertion failed
wrong indexes
slice out of range
cannot wakeup a idle thread
wrong parameter
size must be a number
idx out of range
cannot convert the string
seterrorhandler
_version_
Squirrel 2.2.3 stable
_charsize_
_intsize_
_floatsize_
compare func failed
native
varargs
paramscheck
typecheck
getclass
rawin
getattributes
setattributes
wakeup
getstatus
pcall
pacall
bindenv
c x|y|t
getinfos
tointeger
tofloat
tochar
slice
 s n  n
s s n 
tolower
toupper
extend
insert
remove
resize
reverse
clear
rawget
rawset
rawdelete
setdebughook
enabledebuginfo
getstackinfos
getroottable
setroottable
getconsttable
setconsttable
assert
print
compilestring
newthread
suspend
dummy
collectgarbage
cannot wakeup a running thread
Invalid qsort, probably compare function defect
?7SQClass
10SQInstance
expected ')'
IDENTIFIER
expected '%s'
expected '='
expected ')' or ','
expected '%c'
invalid constant [%s.%s]
can't delete an expression
cannot delete a local
expression expected
parent cannot be set
can't assign expression
can't 'create' a local slot
invalid class name
@INDEX@
@ITERATOR@
function with default parameters cannot have variable number of parameters
cannot brake deref/or comma needed after [exp]=exp slot declaration
expression expected, found ')'
free variables cannot be modified
'break' has to be in a loop block
'continue' has to be in a loop block
cannot create a class in a local with the syntax(class <local>)
scalar expected : integer,float
scalar expected : integer,float or string
end of statement expected (; or lf)
NATIVE
%.14g
the index '%.50s' does not exist
comparsion between '%.50s' and '%.50s'
parameter %d has an invalid type '%s' ; expected: '%s'
false
(%s %p)
internal compiler error: too many literals
internal compiler error: too many locals
15SQFunctionProto
Invalid character
while
break
continue
foreach
catch
throw
clone
yield
resume
switch
default
parent
extends
instanceof
vargc
vargv
static
const
missing "*/" in comment
unfinished string
newline in a constant
hexadecimal number expected
unrecognised escaper char
empty constant
constant too long
invalid octal number
invalid numeric format
exponent expected
string expected
error parsing the string
invalid token '..'
unexpected character(control)
too many digits for an Hex number
_delegate 
native function
userdata
resuming dead generator
resuming active generator
cannot serialize a %s
_lasterror
_errorhandler
_debughook
_roottable
temp_reg
_stack
_vargsstack
_members
_base 
_attributes
_defaultvalues
_methods
_metamethods
_class 
internal vm error, yielding dead generator
internal vm error, yielding a dead generator
io error (write function failure)
io error, read function failure, the origin stream could be corrupted/trucated
invalid or corrupted closure stream
12SQRefCounted
9SQWeakRef
11SQDelegable
8SQString
7SQArray
10SQUserData
9SQClosure
11SQGenerator
15SQNativeClosure
_registry
_consts
_metamethodsmap
_table_default_delegate
_array_default_delegate
_string_default_delegate
_number_default_delegate
_generator_default_delegate
_thread_default_delegate
_closure_default_delegate
_class_default_delegate
_instance_default_delegate
_weakref_default_delegate
userpointer
_modulo
_call
_cloned
_newslot
_delslot
_newmember
_inherited
7SQTable
internal vm error bitwise op failed
bitwise op between '%s' and '%s'
cannot suspend an already suspended vm
cannot suspend through native calls/metamethods
the function doesn't have var args
the %s type doesn't have a parent slot
Script terminated by SQQuerySuspend
cannot apply instanceof between a %s and a %s
attempt to perform a bitwise op on a %s
trying to yield a '%s',only genenerator can be yielded
trying to resume a '%s',only genenerator can be resumed
arith op %c on between '%s' and '%s' (%s)
arith op %c on between '%s' and '%s'
_nexti returned an invalid idx
class instances do not support the new slot operator
trying to modify a class that has already been instantiated
the property '%s' already exists
attempt to delete a slot from a %s
delegating a '%s'
delegate cycle detected
using '%s' as delegate
indexing 'vargv' with %s
vargv index out of range
Native stack overflow
wrong number of parameters
terminated by debugger
attempt to call '%s'
cloning a %s
trying to inherit from a %s
attempt to negate a %s
(weakref : 0x%p [%s] )
(%s : 0x%p)
division by zero
modulo by zero
_nexti failed
cannot iterate %s
indexing %s with %s
trying to set '%s'
null cannot be used as index
cannot delete a slot from %s
4SQVM
.@failed to bind the socket
disconnected
socket error
SERIALIZE_STATE
error on listen(socket)
error accept(socket)
socket failed
*FUNCTION [%s] %s line [%d]
AN ERROR HAS OCCURED [%s]
failed to initialize the debugger
error compiling the serialization function
AN ERROR HAS OCCURED [unknown]
	see copyright notice in sqrdbg.h
local currentscope;
if ( ::getroottable().parent )
	currentscope = ::getroottable();
	::setroottable( ::getroottable().parent );
try {
local objs_reg = { maxid=0 ,refs={} }
complex_types <- {
	["table"] = null,
	["array"] = null,
	["class"] = null,
	["instance"] = null,
	["weakref"] = null,
function build_refs(t):(objs_reg)
	if(t == ::getroottable())
		return;
	local otype = ::type(t);
	if(otype in complex_types)
		if(!(t in objs_reg.refs)) {
			objs_reg.refs[t] <- objs_reg.maxid++;
		    iterateobject(t,function(o,i,val):(objs_reg)
		    {
			    build_refs(val);
			    build_refs(i);
		    })
function getvalue(v):(objs_reg)
	switch(::type(v))
		case "table":
		case "array":
		case "class":
		case "instance":
			return objs_reg.refs[v].tostring();
		case "integer":
		case "float":
		    return v;
		case "bool":
		    return v.tostring();
		case "string":
			return v;
		case "null":
		    return "null";
		default:
			return pack_type(::type(v));
local packed_types={
	["null"]="n",
	["string"]="s",
	["integer"]="i",
	["float"]="f",
	["userdata"]="u",
	["function"]="fn",
	["table"]="t",
	["array"]="a",
	["generator"]="g",
	["thread"]="h",
	["instance"]="x", 
	["class"]="y",  
	["bool"]="b",
	["weakref"]="w"  
function pack_type(type):(packed_types)
	if(type in packed_types)return packed_types[type]
	return type
function iterateobject(obj,func)
	local ty = ::type(obj);
	if(ty == "instance") {
		try { //TRY TO USE _nexti
		    foreach(idx,val in obj)
		    {
				func(obj,idx,val);
		    }
		catch(e) {
		   foreach(idx,val in obj.getclass())
		   {
			func(obj,idx,obj[idx]);
		   }
	else if(ty == "weakref") {
		func(obj,"@ref",obj.ref());
	else {
		foreach(idx,val in obj)
		    func(obj,idx,val);
function build_tree():(objs_reg)
	foreach(i,o in objs_reg.refs)
		beginelement("o");
		attribute("type",(i==::getroottable()?"r":pack_type(::type(i))));
		local _typeof = typeof i;
		if(_typeof != ::type(i)) {
			attribute("typeof",_typeof);
		attribute("ref",o.tostring());
		if(i != ::getroottable()){
			iterateobject(i,function (obj,idx,val) {
				if(::type(val) == "function")
					return;
					
				if ( ::type(idx) == "string" && idx.find( "__" ) == 0 )
					return;
				beginelement("e");	
					emitvalue("kt","kv",idx);
					emitvalue("vt","v",obj[idx]);
				endelement("e");	
			})
		endelement("o");
function evaluate_watch(locals,id,expression)
	local func_src="return function ("
	local params=[];
	params.append(locals["this"])
	local first=1;
	foreach(i,v in locals){
		if(i!="this" && i[0] != '@'){ //foreach iterators start with @
			if(!first){
				func_src=func_src+","
			first=null
			params.append(v)
			func_src=func_src+i
	func_src=func_src+"){\n"
	func_src=func_src+"return ("+expression+")\n}"
	try {
		local func=::compilestring(func_src);
		return {status="ok" , val=func().acall(params)};
	catch(e)
		return {status="error"}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
function emitvalue(type_attrib,value_attrib,val)
	attribute(type_attrib,pack_type(::type(val)));
	attribute(value_attrib,getvalue(val).tostring());
local stack=[]
local level=3;
local si;
	//ENUMERATE THE STACK WATCHES
	while(si=::getstackinfos(level))
		stack.append(si);
		level++;
	//EVALUATE ALL WATCHES
	objs_reg.refs[::getroottable()] <- objs_reg.maxid++;
	foreach(i,val in stack)
		if(val.src!="NATIVE") {
			if("watches" in this) {
				val.watches <- {}
				foreach(i,watch in watches)
				{
					if(val.src!="NATIVE"){
						val.watches[i] <- evaluate_watch(val.locals,i,watch);
						if(val.watches[i].status!="error")
							build_refs(val.watches[i].val);
					}
					else{
						val.watches[i] <- {status="error"}
					}
					val.watches[i].exp <- watch;
				}
		foreach(i,l in val.locals)
			build_refs(l);
	beginelement("objs");
	build_tree();
	endelement("objs");
	beginelement("calls");
	foreach(i,val in stack)
		beginelement("call");
		attribute("fnc",val.func);
		attribute("src",val.src);
		attribute("line",val.line.tostring());
		foreach(i,v in val.locals)
			beginelement("l");
				attribute("name",getvalue(i).tostring());
				emitvalue("type","val",v);
			endelement("l");
		if("watches" in val) {
			foreach(i,v in val.watches)
				beginelement("w");
					attribute("id",i.tostring());
					attribute("exp",v.exp);
					attribute("status",v.status);
					if(v.status!="error") {
						emitvalue("type","val",v.val);
					}
				endelement("w");
		endelement("call");
	endelement("calls");
	objs_reg = null;
	stack = null;
	if("collectgarbage" in ::getroottable()) ::collectgarbage();
}catch(e)
	::print("ERROR"+e+"\n");
if ( currentscope )
	::setroottable( currentscope );
Script debugger disconnected
_sqdbg_debug_hook_
_sqdbg_error_handler_
watches
beginelement
endelement
attribute
vector::_M_default_append
</%s>
 %s="%s"
terminated
the watch does not exists
removed watch %d
the breakpoint doesn't exists
removebreakpoint
addbreakpoint
added bp %d %s
error parsing add breakpoint
removed bp %d %s
resumed
go (execution resumed)
step into
step return
disabled
added watch %d %s
error parsing add watch
terminate from user
ready
unknown packet
added watch %d
error parsing remove watch
&amp;
&apos;
&quot;
&quot;n
&quot;r
error parsing remove breakpoint
%s line = (%d) column = (%d) : error %s
*FUNCTION [%s()] %s line [%d]
AN ERROR HAS OCCURED [unknown]
CALLSTACK
LOCALS
[%s] NULL
[%s] %d
[%s] %.14g
[%s] USERPOINTER
[%s] "%s"
[%s] TABLE
[%s] ARRAY
[%s] CLOSURE
[%s] NATIVECLOSURE
[%s] GENERATOR
[%s] USERDATA
[%s] THREAD
[%s] CLASS
[%s] INSTANCE
[%s] WEAKREF
[%s] %s
resize failed
std_blob
casti2f
castf2i
swap2
swap4
swapfloat
internal error (_nexti) wrong argument type
cannot create blob with negative size
8SQStream
6SQBlob
RAND_MAX
log10
atan2
floor
srand
letter expected
overflow in numeric constant
expected paren
empty class
unfinished range
invalid range
, or } expected
unexpected character
cannot use character classes in ranges
the stream is invalid
no data left to read
invalid format
invalid parameter
invalid origin
std_stream
table expected
readblob
readn
writeblob
writen
flush
regexp
empty separators string
begin
-+ #0
width format too long
precision format too long
lstrip
rstrip
split
search
match
capture
subexpcount
not enough paramters for the given format string
string expected for the specified format
integer expected for the specified format
float expected for the specified format
getVar(): Could not create instance: %s
getVar(): Invalid type+access: 'ScriptStringVarBase' with VAR_ACCESS_CONSTANT (use VAR_ACCESS_READ_ONLY instead)
getVar(): Invalid type+access: 'const SQChar *' without VAR_ACCESS_CONSTANT
getVarInfo: Could not retrieve UserData
getInstanceVarInfo: Could not retrieve UserData
setVar(): Cannot write to constant: %s
INSTANCE type assignment mismatch
setVar(): Cannot write to an SQUserPointer: %s
Invalid Instance Type
13SquirrelError
__SqTypes
14SquirrelObject
unknown error
call already initialized
call not initialized
t|y|x%s
CreateFunction: typeMask string too long.
{}()':
%i %i %i %i
FCVAR_NEVER_AS_STRING
"%s" = "%s"
 ( def. "%s" )
 min. %f
 max. %f
"%s" 
%-80s - %.80s
%-80s
client
archive
notify
singleplayer
notconnected
cheat
replicated
server_can_execute
clientcmd_can_execute
ss_added
Warning:  %s = '%s' is infinite, clamping value.
ConVarRef %s doesn't point to an existing ConVar
 [%.3f server clamped to %.3f]
CCommand::Tokenize: Encountered command which overflows the tokenizer buffer.. Skipping!
CCommand::Tokenize: Encountered command which overflows the argument buffer.. Clamped!
InstallChangeCallback called with NULL callback, ignoring!!!
InstallChangeCallback ignoring duplicate change callback!!!
ConVar(%s) defined with infinite float value (%s)
7IConVar
23IConCommandBaseAccessor
14ConCommandBase
10ConCommand
6ConVar
20ConVar_ServerBounded
16CDefaultAccessor
12CEmptyConVar
_client.so
No such file
image not found
_valveinternal
_xlsp
-xlsp
-valveinternal
DLOPEN Error:%s
BuiltDebug
%s/%s
%s/bin/%s
-allowdebug
Module %s is a debug build
CreateInterface
 failed to dlopen %s error=%s
16CDllDemandLoader
0123456789ABCDEF
 bytes
%%.%if%s
,%03d
UCS-2LE
UCS-4LE
UTF-32LE
UTF-8
[url=
steam://openurl/
steam://openurl_external/
%s %s %s %s
</script>
&nbsp;
&trade;
&copy;
&reg;
&ndash;
&mdash;
&euro;
&iexcl;
&cent;
&pound;
&curren;
&yen;
&brvbar;
&sect;
&uml;
&ordf;
&laquo;
&not;
&shy;
&macr;
&deg;
&plusmn;
&sup2;
&sup3;
&acute;
&micro;
&para;
&middot;
&cedil;
&sup1;
&ordm;
&raquo;
&frac14;
&frac12;
&frac34;
&iquest;
&times;
&divide;
&Agrave;
&Aacute;
&Acirc;
&Atilde;
&Auml;
&Aring;
&AElig;
&Ccedil;
&Egrave;
&Eacute;
&Ecirc;
&Euml;
&Igrave;
&Iacute;
&Icirc;
&Iuml;
&ETH;
&Ntilde;
&Ograve;
&Oacute;
&Ocirc;
&Otilde;
&Ouml;
&Oslash;
&Ugrave;
&Uacute;
&Ucirc;
&Uuml;
&Yacute;
&THORN;
&szlig;
&agrave;
&aacute;
&acirc;
&atilde;
&auml;
&aring;
&aelig;
&ccedil;
&egrave;
&eacute;
&ecirc;
&euml;
&igrave;
&iacute;
&icirc;
&iuml;
&eth;
&ntilde;
&ograve;
&oacute;
&ocirc;
&otilde;
&ouml;
&oslash;
&ugrave;
&uacute;
&ucirc;
&uuml;
&yacute;
&thorn;
&yuml;
&#92;
&#36;
&#35;
[code]
<pre>
[/code]
</pre>
[/h1]
</h1>
[list]
[/list]
</ul>
[/url]
[img]
<img src="
[/img]
"></img>
V_AppendSlash: ran out of space on %s.
V_MakeAbsolutePath: _getcwd failed.
0123456789abcdef
0123456789ABCDEF
,/$`,
?0,/1a,
-&B'-
CUtlBuffer::VaPrintf: String overflowed buffer [%d]
18CUtlCharConversion
21CUtlCStringConversion
19CUtlNoEscConversion
APPSYSTEM: In ConnectInterfaces(), s_nRegistrationCount is %d!
Physics2 Interface ActorMgr v0.1
Physics2 Interface ResourceMgr v0.1
MaterialSystemHardwareConfig013
VEngineCvar007
EventSystem001
VProcessUtils002
Physics2 Interface v0.3
VFileSystem017
VNewAsyncFileSystem001
ResourceSystem004
VMaterialSystem080
VMaterialSystem2_001
InputSystemVersion001
InputStackSystemVersion001
NetworkSystemVersion001
RenderDeviceMgr001
SoundSystem001
DebugTextureInfo001
VBAllocTracker001
COLORCORRECTION_VERSION_1
VP4002
VMDLLIB001
QueuedLoaderVersion001
VResourceAccessControl001
VPrecacheSystem001
VStudioRender026
VGUI_ivgui008
VGUI_Input005
VGUI_Panel009
VGUI_Surface031
VGUI_Scheme010
VGUI_System010
Localize_001
MatSystemSurface006
VDataCache003
MDLCache004
VAvi001
VBik001
VDmeMakeFileUtils001
VPhysicsCollision007
VSoundEmitter003
MeshSystem001
RenderDevice001
RenderHardwareConfig001
SceneSystem_001
WorldRendererMgr001
RenderSystemSurface001
MATCHFRAMEWORK_001
GameUISystemMgr001
PanoramaUIEngine001
PanoramaUIClient001
PanoramaTextServices001
IMEManager001
SSE and SSE2 are required.
'_? A1> A1> A1> A1>
4fff>fff>fff>fff>
C33s?
333333
;*3$"
//===	======= Copyright 
 2008, Valve Corporation, All rights reserved. ========
// Purpose: Script initially run after squirrel VM is initialized
//=============================================================================
//-----------------------------------------------------------------------------
// General
//-----------------------------------------------------------------------------
function printl( text )
	return print( text + "\n" );
function Msg( text )
	return print( text );
function Assert( b, msg = null )
	if ( b )
		return;
	if ( msg != null )
		throw "Assertion failed: " + msg;
	else
		throw "Assertion failed";
//-----------------------------------------------------------------------------
// Documentation table
//-----------------------------------------------------------------------------
if ( developer() > 0 )
	Documentation <-
		classes = {}
		functions = {}
		instances = {}
	function RetrieveNativeSignature( nativeFunction )
		if ( nativeFunction in NativeFunctionSignatures )
			return NativeFunctionSignatures[nativeFunction]
		return "<unnamed>"
	function RegisterFunctionDocumentation( func, name, signature, description )
		if ( description.len() )
			local b = ( description[0] == '#' );
			if ( description[0] == '#' )
				local colon = description.find( ":" );
				if ( colon == null )
				{
					colon = description.len();
				}
				local alias = description.slice( 1, colon );
				description = description.slice( colon + 1 );
				name = alias;
				signature = "#";
		Documentation.functions[name] <- [ signature, description ]
	function Document( symbolOrTable, itemIfSymbol = null, descriptionIfSymbol = null )
		if ( typeof( symbolOrTable ) == "table" )
			foreach( symbol, itemDescription in symbolOrTable )
				Assert( typeof(symbol) == "string" )
				Document( symbol, itemDescription[0], itemDescription[1] );
		else
			printl( symbolOrTable + ":" + itemIfSymbol.tostring() + "/" + descriptionIfSymbol );
	function PrintHelp( string = "*", exact = false )
		local matches = []
		if ( string == "*" || !exact )
			foreach( name, documentation in Documentation.functions )
				if ( string != "*" && name.tolower().find( string.tolower() ) == null )
				{
					continue;
				}
				matches.append( name ); 
		else if ( exact )
			if ( string in Documentation.functions )
				matches.append( string )
		if ( matches.len() == 0 )
			printl( "Symbol " + string + " not found" );
			return;
		matches.sort();
		foreach( name in matches )
			local result = name;
			local documentation = Documentation.functions[name];
			printl( "Function:    " + name );
			local signature;
			if ( documentation[0] != "#" )
				signature = documentation[0];
			else
				signature = GetFunctionSignature( this[name], name );
			printl( "Signature:   " + signature );
			if ( documentation[1].len() )
				printl( "Description: " + documentation[1] );
			print( "\n" ); 
	function RetrieveNativeSignature( nativeFunction ) { return "<unnamed>"; }
	function Document( symbolOrTable, itemIfSymbol = null, descriptionIfSymbol = null ) {}
	function PrintHelp( string = "*", exact = false ) {}
//-----------------------------------------------------------------------------
// VSquirrel support functions
//-----------------------------------------------------------------------------
function VSquirrel_OnCreateScope( name, outer )
	local result;
	if ( !(name in outer) )
		result = outer[name] <- { __vname=name, __vrefs = 1 };
		delegate outer : result;
	else
		result = outer[name];
		result.(void, long double,...)(float, short) += 1;
	return result;
function VSquirrel_OnReleaseScope( scope )
	scope.(void, long double,...)(float, short) -= 1;
	if ( scope.(void, long double,...)(float, short) < 0 )
		throw "Bad reference counting on scope " + scope.__vname;
	else if ( scope.(void, long double,...)(float, short) == 0 )
		delete scope.parent[scope.__vname];
		scope.__vname = null;
		delegate null : scope;
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
class CCallChainer
	constructor( prefixString, scopeForThis = null )
		prefix = prefixString;
		if ( scopeForThis != null )
			scope = scopeForThis;
		else
			scope = ::getroottable();
		chains = {};
		// Expose a bound global function to dispatch to this object
		scope[ "Dispatch" + prefixString ] <- Call.bindenv( this );
	function PostScriptExecute() 
		foreach( key, value in scope )
			if ( typeof( value ) == "function" ) 
				if ( key.find( prefix ) == 0 )
				{
					key = key.slice( prefix.len() );
					
					if ( !(key in chains) )
					{
						//::print( "Creating new call chain " + key + "\n");
						chains[key] <- [];
					}
					
					local chain = chains[key];
					
					if ( !chain.len() || chain.top() != value )
					{
						chain.push( value );
						//::print( "Added " + value + " to call chain " + key + "\n" );
					}
				}
	function Call( event, ... )
		if ( event in chains )
			local chain = chains[event];
			if ( chain.len() )
				local i;
				local args = [];
				if ( vargc > 0 )
				{
					args.push( scope );
					for ( i = 0; i < vargc; i++ )
					{
						args.push( vargv[i] );
					}
				}
				for ( i = chain.len() - 1; i >= 0; i -= 1 )
				{
					local func = chain[i];
					local result;
					if ( !args.len() )
					{
						result = func();
					}
					else
					{
						result = func.acall( args ); 
					}
					if ( result != null && !result )
						return false;
				}
		return true;
	scope = null;
	prefix = null;
	chains = null;
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
class CSimpleCallChainer
	constructor( prefixString, scopeForThis = null, exactNameMatch = false )
		prefix = prefixString;
		if ( scopeForThis != null )
			scope = scopeForThis;
		else
			scope = ::getroottable();
		chain = [];
		// Expose a bound global function to dispatch to this object
		scope[ "Dispatch" + prefixString ] <- Call.bindenv( this );
		exactMatch = exactNameMatch
	function PostScriptExecute() 
		foreach( key, value in scope )
			if ( typeof( value ) == "function" ) 
				local foundMatch = false;
				if ( exactMatch )
				{
					foundMatch = ( prefix == key );
				}
				else
				{
					foundMatch = ( key.find( prefix ) == 0 )
				}
						
				if ( foundMatch )
				{
					if ( !exactMatch )
						key = key.slice( prefix.len() );
					
					if ( !(chain) )
					{
						//::print( "Creating new call simple chain\n");
						chain <- [];
					}
					
					if ( !chain.len() || chain != value )
					{
						chain.push( value );
						//::print( "Added " + value + " to call chain.\n" );
					}
				}
	function Call( ... )
		if ( chain.len() )
			local i;
			local args = [];
			if ( vargc > 0 )
				args.push( scope );
				for ( i = 0; i < vargc; i++ )
				{
					args.push( vargv[i] );
				}
			for ( i = chain.len() - 1; i >= 0; i -= 1 )
				local func = chain[i];
				local result;
				if ( !args.len() )
				{
					result = func.pcall( scope );
				}
				else
				{
					result = func.pacall( scope, args ); 
				}
				if ( result != null && !result )
					return false;
		return true;
	exactMatch = false
	scope = null;
	prefix = null;
	chain = null;
//-----------------------------------------------------------------------------
// Late binding: allows a table to refer to parts of itself, it's children,
// it's owner, and then have the references fixed up after it's fully parsed
// Usage:
//    lateBinder <- LateBinder();
//    lateBinder.Begin( this );
//    
//    Test1 <-
//    {   
// 	   Foo=1
//    }   
//    
//    Test2 <-
//    {   
// 	   FooFoo = "I'm foo foo"
// 	   BarBar="@Test1.Foo"
// 	   SubTable = { boo=[bah, "@Test2.FooFoo", "@Test1.Foo"], booboo2={one=bah, two="@Test2.FooFoo", three="@Test1.Foo"} }
// 	   booboo=[bah, "@Test2.FooFoo", "@Test1.Foo"]
// 	   booboo2={one=bah, two="@Test2.FooFoo", three="@Test1.Foo"}
// 	   bah=wha
//    }   
//    
//    lateBinder.End();
//    delete lateBinder;
// When End() is called, all of the unresolved symbols in the tables and arrays will be resolved,
// any left unresolved will become a string prepended with '~', which later code can deal with
//-----------------------------------------------------------------------------
class LateBinder
	// public:
	function Begin( target, log = false )
		m_log = log;
		HookRootMetamethod( "_get", function( key ) { return "^" + key; } );
		HookRootMetamethod( "_newslot", function( key, value ) { if ( typeof value == "table" ) { m_fixupSet.push( [ key, value ] ); this.rawset( key, value ); };  }.bindenv(this) );
		m_targetTable = target;
		Log( "Begin late bind on table " + m_targetTable );
	function End()
		UnhookRootMetamethod( "_get" );
		UnhookRootMetamethod( "_newslot" );
		Log( "End late bind on table " + m_targetTable );
		foreach( subTablePair in m_fixupSet )
			EstablishDelegation( m_targetTable, subTablePair[1] );
		Log( "Begin resolution... " )
		m_logIndent++;
		local found = true;
		while ( found )
			foreach( subTablePair in m_fixupSet )
				Log( subTablePair[0] + " = " );
				Log( "{" );
				if ( !Resolve( subTablePair[1], subTablePair[1], false ) )
				{
					found = false;
				}
				Log( "}" );
		m_logIndent--;
		foreach( subTablePair in m_fixupSet )
			RemoveDelegation( subTablePair[1] );
		Log( "...end resolution" );
	// private:
	function HookRootMetamethod( name, value )
		local saved = null;
		local roottable = getroottable();
		if ( name in roottable )
			saved = roottable[name];
		roottable[name] <- value;
		roottable["__saved" + name] <- saved;
	function UnhookRootMetamethod( name )
		local saveSlot = "__saved" + name;
		local roottable = getroottable();
		local saved = roottable[saveSlot];
		if ( saved != null )
			roottable[name] = saved;
		else
			delete roottable[name];
		delete roottable[saveSlot];
	function EstablishDelegation( parentTable, childTable )
		delegate parentTable : childTable;
		foreach( key, value in childTable )
			local type = typeof value;
			if ( type == "table" )
				EstablishDelegation( childTable, value );
	function RemoveDelegation( childTable )
		delegate null : childTable;
		foreach( key, value in childTable )
			local type = typeof value;
			if ( type == "table" )
				RemoveDelegation( value );
	function Resolve( lookupTable, subTableOrArray, throwException = false )
		m_logIndent++;
		local found = false;
		foreach( key, value in subTableOrArray )
			local type = typeof value;
			if ( type == "string" )
				if ( value.len() )
				{
					local unresolvedId = null;
					local controlChar = value[0]
					if ( controlChar == '^' )
					{
						found = true;
						value = value.slice( 1 );
						if ( value in lookupTable )
						{
							subTableOrArray[key] = lookupTable[value];
							Log( key + " = " + lookupTable[value] + " <-- " + value );
						}
						else
						{
							subTableOrArray[key] = "~" + value;
							unresolvedId = value;
							Log( key + " = \"" + "~" + value + "\" (unresolved)" );
						}
					}
					else if ( controlChar == '@' )
					{
						found = true;
						local identifiers = [];
						local iLast = 1;
						local iNext;
						while ( ( iNext = value.find( ".", iLast ) ) != null )
						{
							identifiers.push( value.slice( iLast, iNext ) );
							iLast = iNext + 1;
						}
						identifiers.push( value.slice( iLast ) );
						
						local depthSuccess = 0;
						local result = lookupTable;
						foreach( identifier in identifiers )
						{
							if ( identifier in result )
							{
								depthSuccess++;
								result = result[identifier];
							}
							else
							{
								break;
							}
						}
						if ( depthSuccess == identifiers.len() )
						{
							subTableOrArray[key] = result;
							Log( key + " = " + result + " <-- " + value );
						}
						else
						{
							subTableOrArray[key] = "~" + value.slice( 1 );
							unresolvedId = value;
							Log( key + " = \"" + "~" + value + "\" (unresolved)" );
						}
					}
					
					if ( unresolvedId != null )
					{
						if ( throwException )
						{
							local exception = "Unresolved symbol: " + bind + " in ";
							foreach ( entry in m_bindNamesStack )
							{
								exception += entry;
								exception += "."
							}
							exception += unresolvedId;
							
							throw exception; 
						}
					}
				}
		foreach( key, value in subTableOrArray )
			local type = typeof value;
			local isTable = ( type == "table" );
			local isArray = ( type == "array" )
			if ( isTable || isArray )
				Log( key + " =" );
				Log( isTable ? "{" : "[" );
				m_bindNamesStack.push( key );
				if ( Resolve( ( isTable ) ? value : lookupTable, value, throwException ) )
				{
					found = true;
				}
				m_bindNamesStack.pop();
				Log( isTable ? "}" : "]" );
		m_logIndent--;
		return found;
	function Log( string )
		if ( m_log )
			for ( local i = 0; i < m_logIndent; i++ )
				print( "  " );
			printl( string );
	m_targetTable = null;
	m_fixupSet = [];
	m_bindNamesStack = [];
	m_log = false;
	m_logIndent = 0;
r""\\
GCC: (Ubuntu 4.8.1-2ubuntu1~12.04+steamrt2+srt1) 4.8.1
.symtab
.strtab
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.data.rel.ro
.dynamic
.got.plt
.data
.comment
.gnu_debuglink
_ZSt20__throw_length_errorPKc@@GLIBCXX_3.4
chdir@@GLIBC_2.2.5
__acosf_finite@@GLIBC_2.15
sincosf@@GLIBC_2.2.5
__log_finite@@GLIBC_2.15
wcsncat@@GLIBC_2.2.5
RandomFloat
memset@@GLIBC_2.2.5
wcsncpy@@GLIBC_2.2.5
wcslen@@GLIBC_2.2.5
__exp_finite@@GLIBC_2.15
close@@GLIBC_2.2.5
__longjmp_chk@@GLIBC_2.11
abort@@GLIBC_2.2.5
strncat@@GLIBC_2.2.5
tanf@@GLIBC_2.2.5
__cxa_guard_acquire@@CXXABI_1.3
tan@@GLIBC_2.2.5
__gmon_start__
_Jv_RegisterClasses
puts@@GLIBC_2.2.5
_setjmp@@GLIBC_2.2.5
_ZNSs4_Rep10_M_disposeERKSaIcE@@GLIBCXX_3.4
toupper@@GLIBC_2.2.5
select@@GLIBC_2.2.5
__printf_chk@@GLIBC_2.3.4
__atan2f_finite@@GLIBC_2.15
strcasecmp@@GLIBC_2.2.5
__vswprintf_chk@@GLIBC_2.4
Plat_MSTime
_fini
__cxa_rethrow@@CXXABI_1.3
malloc@@GLIBC_2.2.5
LoggingSystem_Log
recv@@GLIBC_2.2.5
_ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base@@GLIBCXX_3.4
iscntrl@@GLIBC_2.2.5
__memcpy_chk@@GLIBC_2.3.4
cos@@GLIBC_2.2.5
RandomInt
__cxa_atexit@@GLIBC_2.2.5
CreateInterface
__vsnprintf_chk@@GLIBC_2.3.4
iconv_open@@GLIBC_2.2.5
_ITM_deregisterTMCloneTable
strnlen@@GLIBC_2.2.5
_Z6DevMsgPKcz
free@@GLIBC_2.2.5
atan@@GLIBC_2.2.5
strlen@@GLIBC_2.2.5
__atan2_finite@@GLIBC_2.15
_ITM_registerTMCloneTable
_ZNSs4_Rep10_M_destroyERKSaIcE@@GLIBCXX_3.4
WriteMiniDump
isupper@@GLIBC_2.2.5
GetCPUInformation
listen@@GLIBC_2.2.5
__cxa_finalize@@GLIBC_2.2.5
__vsprintf_chk@@GLIBC_2.3.4
LoggingSystem_IsChannelEnabled
iswalpha@@GLIBC_2.2.5
_ZTVN10__cxxabiv117__class_type_infoE@@CXXABI_1.3
__cxa_guard_release@@CXXABI_1.3
dlerror@@GLIBC_2.2.5
iswalnum@@GLIBC_2.2.5
mbstowcs@@GLIBC_2.2.5
towupper@@GLIBC_2.2.5
g_pMemAlloc
sscanf@@GLIBC_2.2.5
_ZSt18_Rb_tree_incrementPKSt18_Rb_tree_node_base@@GLIBCXX_3.4
Error
iconv@@GLIBC_2.2.5
dlclose@@GLIBC_2.2.5
_ZNSs6appendEmc@@GLIBCXX_3.4
strstr@@GLIBC_2.2.5
iswspace@@GLIBC_2.2.5
__dynamic_cast@@CXXABI_1.3
strtol@@GLIBC_2.2.5
towlower@@GLIBC_2.2.5
__pow_finite@@GLIBC_2.15
__strcpy_chk@@GLIBC_2.3.4
memmove@@GLIBC_2.2.5
strchr@@GLIBC_2.2.5
cbrtf@@GLIBC_2.2.5
socket@@GLIBC_2.2.5
dl_iterate_phdr@@GLIBC_2.2.5
__bss_start
_ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_@@GLIBCXX_3.4
isalpha@@GLIBC_2.2.5
_ZTVN10__cxxabiv120__si_class_type_infoE@@CXXABI_1.3
_Z6ConMsgPKcz
__stack_chk_fail@@GLIBC_2.4
LOG_GENERAL
_ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_@@GLIBCXX_3.4
strcmp@@GLIBC_2.2.5
tolower@@GLIBC_2.2.5
__cxa_allocate_exception@@CXXABI_1.3
__log10_finite@@GLIBC_2.15
getcwd@@GLIBC_2.2.5
send@@GLIBC_2.2.5
wcschr@@GLIBC_2.2.5
_ZNSs6assignEPKcm@@GLIBCXX_3.4
__cxa_free_exception@@CXXABI_1.3
strcpy@@GLIBC_2.2.5
strtok@@GLIBC_2.2.5
_ZNSs6assignERKSs@@GLIBCXX_3.4
RandomSeed
srand@@GLIBC_2.2.5
Plat_FloatTime
s_pInterfaceRegs
ThreadSleep
pthread_once@@GLIBC_2.2.5
memcmp@@GLIBC_2.2.5
_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3
Plat_ExitProcess
__cxa_throw@@CXXABI_1.3
dlopen@@GLIBC_2.2.5
isalnum@@GLIBC_2.2.5
__expf_finite@@GLIBC_2.15
isspace@@GLIBC_2.2.5
strtoull@@GLIBC_2.2.5
ispunct@@GLIBC_2.2.5
dlsym@@GLIBC_2.2.5
__cxa_end_catch@@CXXABI_1.3
isxdigit@@GLIBC_2.2.5
_ZNSs4_Rep20_S_empty_rep_storageE@@GLIBCXX_3.4
__sprintf_chk@@GLIBC_2.3.4
__snprintf_chk@@GLIBC_2.3.4
__pthread_key_create@@GLIBC_2.2.5
strtoll@@GLIBC_2.2.5
__cxa_begin_catch@@CXXABI_1.3
bind@@GLIBC_2.2.5
_Z10DevWarningPKcz
pthread_mutex_lock@@GLIBC_2.2.5
Warning
Plat_IsInDebugSession
sinf@@GLIBC_2.2.5
rand@@GLIBC_2.2.5
_edata
CommandLine
__gxx_personality_v0@@CXXABI_1.3
accept@@GLIBC_2.2.5
strtoul@@GLIBC_2.2.5
pthread_mutex_unlock@@GLIBC_2.2.5
memcpy@@GLIBC_2.14
iconv_close@@GLIBC_2.2.5
sin@@GLIBC_2.2.5
islower@@GLIBC_2.2.5
strtod@@GLIBC_2.2.5
__fdelt_chk@@GLIBC_2.15
isprint@@GLIBC_2.2.5
__acos_finite@@GLIBC_2.15
_init
__asin_finite@@GLIBC_2.15
wcstombs@@GLIBC_2.2.5
vscript_client.so.dbg
