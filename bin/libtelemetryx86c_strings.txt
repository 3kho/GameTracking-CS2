__gmon_start__
_fini
__cxa_finalize
_Jv_RegisterClasses
inet_ntoa
fwrite
fclose
__sprintf_chk
fopen
malloc
gethostname
tmGetAPI
__vsprintf_chk
__printf_chk
stdout
fflush
memcpy
memset
__snprintf_chk
strlen
__memcpy_chk
memmove
pthread_self
getpid
readlink
backtrace
dladdr
fread
getlogin_r
popen
fgets
pclose
sscanf
strtol
pthread_getschedparam
pthread_setschedparam
sched_get_priority_max
vfprintf
socket
setsockopt
__errno_location
usleep
fcntl
gethostbyname
connect
select
getsockopt
getifaddrs
freeifaddrs
perror
listen
accept
pthread_getspecific
pthread_detach
pthread_setspecific
sem_wait
sem_init
pthread_attr_init
pthread_attr_setstacksize
pthread_create
pthread_attr_destroy
sem_destroy
sem_post
pthread_key_create
pthread_setaffinity_np
gettimeofday
pthread_timedjoin_np
pthread_tryjoin_np
pthread_join
pthread_mutexattr_init
pthread_mutexattr_settype
pthread_mutex_init
pthread_mutex_destroy
pthread_mutex_lock
pthread_mutex_unlock
pthread_mutex_timedlock
pthread_mutex_trylock
pthread_yield
sem_trywait
sem_timedwait
sched_get_priority_min
sysconf
libpthread.so.0
libdl.so.2
libc.so.6
_edata
__bss_start
$ORIGIN
GLIBC_2.0
GLIBC_2.3
GLIBC_2.1.3
GLIBC_2.1
GLIBC_2.3.4
GLIBC_2.3.3
GLIBC_2.2
,[^_]
,[^_]
<[^_]
|&~l1
<[^_]
\[^_]
<[^_]
t~;5$
tv;5(
tn;5,
tf;50
t^;54
tV;58
tN;5<
tF;5@
t>;5D
t6;5H
t.;5L
t&;5P
l[^_]
\[^_]
t{;=$
ts;=(
tk;=,
tc;=0
t[;=4
tS;=8
tK;=<
tC;=@
t;;=D
t3;=H
t+;=L
t#;=P
L[^_]
L[^_]
|[^_]
l[^_]
\[^_]
\[^_]
\[^_]
\[^_]
L[^_]
L[^_]
l[^_]
l[^_]
l[^_]
L[^_]
L[^_]
\[^_]
l[^_]
,[^_]
,[^_]
,[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
 t@f=
l[^_]
\[^_]
\[^_]
\[^_]
\[^_]
t~;5$
tv;5(
tn;5,
tf;50
t^;54
tV;58
tN;5<
tF;5@
t>;5D
t6;5H
t.;5L
t&;5P
t~;5$
tv;5(
tn;5,
tf;50
t^;54
tV;58
tN;5<
tF;5@
t>;5D
t6;5H
t.;5L
t&;5P
l[^_]
l[^_]
\[^_]
\[^_]
t~;5$
tv;5(
tn;5,
tf;50
t^;54
tV;58
tN;5<
tF;5@
t>;5D
t6;5H
t.;5L
t&;5P
l[^_]
l[^_]
\[^_]
\[^_]
l[^_]
l[^_]
l[^_]
l[^_]
<\tT</tP
L[^_]
,[^_]
3N,3^(	
<3th<6
\[^_]
,[^_]
,[^_]
,[^_]
ul;D$
u,;l$
TCP(RAD)
%s.%03d
%s/%s
(telemetry/flipBufferPointers)trickle
(telemetry/flipBufferPointers)space
(telemetry/flipBufferPointers)explicit
Telemetry[WARNING]: %s Invalid pointer passed to tmCoreGetPlatformInformation
Telemetry[WARNING]: %s Invalid context passed to tmCoreGetPlatformInformation
Telemetry[WARNING]: %s Invalid information type
Telemetry[WARNING]: %s Invalid context
Telemetry[WARNING]: %s mismatched format codes!
Telemetry[WARNING]: %s Telemetry uninitialized
Telemetry[WARNING]: %s Invalid lock result '%d' passed to tmCoreEndTryLock
Telemetry[WARNING]: %s Called tmSetLockStateMinTime with corrupt buffer
Telemetry[WARNING]: %s Invalid lock state '%d'
Telemetry[WARNING]: %s Invalid parameter
Telemetry[WARNING]: %s NULL string passed
Telemetry[WARNING]: %s tmUnwindToDebugZoneLevel has been deprecated and is disabled!
Telemetry[WARNING]: %s tmCheckDebugZoneLevel has been deprecated and is disabled!
Telemetry[WARNING]: %s tmSetDebugZoneLevel has been deprecated and is disabled!
Telemetry[WARNING]: %s NULL passed for name or desc
Telemetry[LOG]: %s Stack var! ref = 0x%p var = 0x%p
Telemetry[WARNING]: %s Stack variable passed for name!
Telemetry[ERROR]: %s Invalid parameter(s)
Telemetry[WARNING]: %s Context size > 4MB...this may impact performance!  1-2MB recommended!
Telemetry[ERROR]: %s Attempting to reinitialize a valid context!  You must call tmShutdownContext first!
Telemetry[LOG]: %s Telemetry base context size: %d bytes
Telemetry[ERROR]: %s Not enough memory, Telemetry requires at least %d bytes
Telemetry[WARNING]: %s Unknown option '%d'
Telemetry[WARNING]: %s Invalid parameter '%d', assuming %d
Telemetry[LOG]: %s Emulated tools version %d
Telemetry[WARNING]: %s Invalid socket buffer size parameter
Telemetry[WARNING]: %s Invalid value %d for TMP_LOCK_MIN_TIME
Telemetry[WARNING]: %s Invalid value %d for TMP_TELEMETRY_PREFERRED_CPU
Telemetry[WARNING]: %s Invalid parameter value %d passed to tmSetParameter
Telemetry[ERROR]: %s Telemetry uninitialized
Telemetry[WARNING]: %s Invalid context
Telemetry[WARNING]: %s Telemetry already shut down
Telemetry[LOG]: %s Waiting for handshake
Telemetry[LOG]: %s cmd: 0x%x size: 0x%x
Telemetry[WARNING]: %s Unknown protocol version 0x%x!
Telemetry[LOG]: %s Using tools version 0x%x
Telemetry[LOG]: %s Handshake received
Telemetry[WARNING]: %s Handshake indicates server side failure with msg '%s'
Telemetry[WARNING]: %s Unknown server cmd 0x%x
Telemetry[WARNING]: %s Timed out waiting for handshake
Telemetry[WARNING]: %s tmCoreStartup called multiple times
Telemetry[WARNING]: %s User timer precision is too low!  Microsecond accurate timer is required!
Telemetry[WARNING]: %s NULL name specified
Telemetry[WARNING]: %s Stack variable specified for name
Telemetry[WARNING]: %s Invalid buffer parameter
Telemetry[WARNING]: %s NULL format specifier passed
Telemetry[WARNING]: %s Stack variable used for format string
Telemetry[WARNING]: %s NULL key or value passed
Telemetry[WARNING]: %s Dynamic strings not allowed for value string!
Telemetry[LOG]: %s finding map signatures
Telemetry[LOG]: %s found map signatures
Telemetry[LOG]: %s clearing map signature %d (%s) : %s
Telemetry[LOG]: %s found %d map signatures
Telemetry[WARNING]: %s Stack variable used for name
/home/telemetry/devel/projects/telemetry/src/sdk/tmcore.cpp
Telemetry[LOG]: %s tick [v%d]%d @ 0x%llx
Telemetry[WARNING]: %s NULL passed for name or file
Telemetry[WARNING]: %s Mutex name table full
Telemetry[WARNING]: %s Negative zone total
Telemetry[WARNING]: %s Stack variable passed for description!
Telemetry[WARNING]: %s Stack variable used for location
Telemetry[WARNING]: %s Invalid connection type '%d'
Telemetry[LOG]: %s Initializing networking system (TMOF_INIT_NETWORKING)
Telemetry[WARNING]: %s Could not start system networking subsystem!
Telemetry[WARNING]: %s Application logical path '%s' is an invalid name
Telemetry[WARNING]: %s Application name '%s' is an invalid name (must be alphanumeric and not contain spaces)
Telemetry[LOG]: %s tmOpen - (%s)%s (%s), %s:%d
Telemetry[LOG]: %s build: Sep 12 2014 10:36:13
Telemetry[LOG]: %s version: 2.0P(CHECKED)
Telemetry[WARNING]: %s Failed to open network connection.
Telemetry[LOG]: %s Starting tmio thread
Telemetry[LOG]: %s ...tmio thread running
Telemetry[WARNING]: %s Bad handshake, disconnecting
Telemetry[WARNING]: %s Missing handshake, disconnecting
<telemetry>
telemetry_lockWriteBuffer
<tmZone>
(stack variable!)
<stack variable!>
$*map%d
(telemetry)tick (ms)
tmTick
(telemetry)buffer size
telemetry/buffer size
bool TmContext::processServerCommands_noLock(int)
TmErrorCode itmCoreStartup()
void itmCoreShutdown()
TmErrorCode itmCoreGetLastError(HTELEMETRY)
void itmCoreSetServerConfiguration(HTELEMETRY, TmServerConfiguration, const void*)
void itmCoreSetParameter(HTELEMETRY, TmParameter, const void*)
void itmCoreEnable(HTELEMETRY, TmOption, int)
int itmCoreIsEnabled(HTELEMETRY, TmOption)
void itmCoreUpdateSymbolData(HTELEMETRY)
void itmCoreClearStaticString(HTELEMETRY, const char*)
TmErrorCode itmCoreInitializeContext(TmContext**, void*, U32)
TmErrorCode itmCoreOpen(HTELEMETRY, const char*, const char*, const char*, TmConnectionType, U16, U32, int)
void itmCoreTick(HTELEMETRY)
void itmCoreLeave(HTELEMETRY, U64, U32, const char*, int)
TmConnectionStatus itmCoreGetConnectionStatus(HTELEMETRY)
void itmCoreFlush(HTELEMETRY)
S32 itmCoreGetStati(HTELEMETRY, TmStat)
void itmCoreClose(HTELEMETRY)
void itmCoreLockName(HTELEMETRY, const void*, TmFormatCode*, const char*, ...)
bool sIsStackVar(const void*, const void*)
void sCoreLockNameV(TmContext*, U64, TmFormatCode*, const char*, char**)
static void TmContext::sThreadNameV(TmContext*, U32, TmFormatCode*, const char*, char**)
void itmCoreThreadName(HTELEMETRY, U32, TmFormatCode*, const char*, ...)
void sCoreEnterV(HTELEMETRY, U64*, U32, U64, U32, const char*, U32, TmFormatCode*, const char*, char**)
void itmCoreSetDebugZoneLevel(HTELEMETRY, int)
void itmCoreCheckDebugZoneLevel(HTELEMETRY, int)
void itmCoreUnwindToDebugZoneLevel(HTELEMETRY, int)
void itmCoreMessage(HTELEMETRY, U32, U32, TmFormatCode*, const char*, ...)
void sCoreMessageV(TmContext*, U32, U32, TmFormatCode*, const char*, char**)
const char* itmCoreDynamicString(HTELEMETRY, const char*)
void itmCoreSetVariable(HTELEMETRY, const char*, TmFormatCode*, const char*, ...)
void sCoreSetVariableV(TmContext*, const char*, TmFormatCode*, const char*, char**)
void itmCoreAlloc(HTELEMETRY, const void*, U64, const char*, U32, TmFormatCode*, const char*, ...)
void sCoreAllocV(TmContext*, const void*, U64, const char*, U32, TmFormatCode*, const char*, char**)
void itmCoreFree(HTELEMETRY, const void*, const char*, int, TmFormatCode*)
int itmCoreSetLockStateMinTime(HTELEMETRY, void*, const void*, TmLockState, const char*, U32, TmFormatCode*, const char*, ...)
int sSetLockStateV(TmContext*, void*, U64, TmLockState, U64, const char*, U32, TmFormatCode*, const char*, char**)
void itmCoreSetLockState(HTELEMETRY, const void*, TmLockState, const char*, U32, TmFormatCode*, const char*, ...)
void itmCoreBeginTimeSpan(HTELEMETRY, U64, U32, U64, const char*, U32, TmFormatCode*, const char*, ...)
void itmCoreEndTimeSpan(HTELEMETRY, U64, U32, U64, const char*, U32, TmFormatCode*, const char*, ...)
void itmCoreSignalLockCount(HTELEMETRY, const char*, U32, const void*, U32, TmFormatCode*, const char*, ...)
void sCoreSignalLockCount(TmContext*, const char*, U32, const void*, U32, TmFormatCode*, const char*, char**)
void itmCoreTryLock(HTELEMETRY, U64*, U64, const char*, U32, const void*, TmFormatCode*, const char*, ...)
void sCoreTryLockV(TmContext*, U64, U64, const char*, U32, const void*, TmFormatCode*, const char*, char**)
void itmCoreEndTryLock(HTELEMETRY, U64, const char*, int, TmFormatCode*, const void*, TmLockResult)
void sCoreDisjointBlobV(HTELEMETRY, int, const void**, const int*, const char*, TmFormatCode*, const char*, char**)
void sCorePlotV(HTELEMETRY, S64, TmPlotType, U32, T, TmFormatCode*, const char*, char**) [with T = float, int type = 0, HTELEMETRY = TmContext*, S64 = long long int, TmPlotType = TmPlotType, U32 = unsigned int, TmFormatCode = _TmFormatCode, va_list = char*]
void sCorePlotV(HTELEMETRY, S64, TmPlotType, U32, T, TmFormatCode*, const char*, char**) [with T = double, int type = 1, HTELEMETRY = TmContext*, S64 = long long int, TmPlotType = TmPlotType, U32 = unsigned int, TmFormatCode = _TmFormatCode, va_list = char*]
void sCorePlotV(HTELEMETRY, S64, TmPlotType, U32, T, TmFormatCode*, const char*, char**) [with T = int, int type = 2, HTELEMETRY = TmContext*, S64 = long long int, TmPlotType = TmPlotType, U32 = unsigned int, TmFormatCode = _TmFormatCode, va_list = char*]
void sCorePlotV(HTELEMETRY, S64, TmPlotType, U32, T, TmFormatCode*, const char*, char**) [with T = unsigned int, int type = 3, HTELEMETRY = TmContext*, S64 = long long int, TmPlotType = TmPlotType, U32 = unsigned int, TmFormatCode = _TmFormatCode, va_list = char*]
void sCorePlotV(HTELEMETRY, S64, TmPlotType, U32, T, TmFormatCode*, const char*, char**) [with T = long long int, int type = 4, HTELEMETRY = TmContext*, S64 = long long int, TmPlotType = TmPlotType, U32 = unsigned int, TmFormatCode = _TmFormatCode, va_list = char*]
void sCorePlotV(HTELEMETRY, S64, TmPlotType, U32, T, TmFormatCode*, const char*, char**) [with T = long long unsigned int, int type = 5, HTELEMETRY = TmContext*, S64 = long long int, TmPlotType = TmPlotType, U32 = unsigned int, TmFormatCode = _TmFormatCode, va_list = char*]
void itmCoreShutdownContext(HTELEMETRY)
int itmCoreIsPaused(HTELEMETRY)
void itmCorePause(HTELEMETRY, int)
void itmCoreSetTimelineSectionName(HTELEMETRY, TmFormatCode*, const char*, ...)
void sCoreSetTimelineSectionNameV(TmContext*, TmFormatCode*, const char*, char**)
void itmCoreEmitAccumulationZone(HTELEMETRY, U64*, U64, U32, U32, const char*, U32, TmFormatCode*, const char*, ...)
void sCoreEmitAccumulationZoneV(TmContext*, U64*, U64, U32, U32, const char*, U32, TmFormatCode*, const char*, char**)
int itmCoreSendCallStack(HTELEMETRY, const TmCallStack*, int)
int itmCoreGetCallStack(HTELEMETRY, TmCallStack*)
int itmCoreGetCallStackR(HTELEMETRY, TmCallStack*)
TmErrorCode itmCoreGetSessionName(HTELEMETRY, char*, int)
TmErrorCode itmCoreGetPlatformInformation(void*, TmPlatformInformation, void*, U32)
<corrupt>
<unregistered ELF>
tmdata
Telemetry[LOG]: %s done
2.0P(CHECKED)
<telemetry:io>
telemetry/processing_time
(telemetry)network bytes
telemetry/network bytes
waiting for data
process
(telemetry/send)send
<tmio>
localdisk
Telemetry[WARNING]: %s TmStringTable_Put - capacity over 50%%
Telemetry[LOG]: %s Found corrupt string!
Telemetry[LOG]: %s Creating connection
Telemetry[WARNING]: %s Failed to create connection
Telemetry[LOG]: %s Attempting to connect (timeout = %d ms)
Telemetry[WARNING]: %s Could not connect!
Telemetry[LOG]: %s Connection established
Telemetry[WARNING]: %s Failed to send TM_APP_MAGIC
Telemetry[LOG]: %s Closing network connections
Telemetry[LOG]: %s Waiting for io connection to close
Telemetry[LOG]: %s Waiting for disconnect
(telemetry)processing time(ms)
(telemetry)context switches(tevent)
telemetry/context switches(tevent)
Telemetry[LOG]: %s Data collection connection closed (reason=%d,remotely=%d)
TmErrorCode TmIo::openNetworkConnections(TmContext*, int, int)
void TmIo::closeNetworkConnections()
long long unsigned int TmIo::putString(unsigned int, const char*, TmOutputBuffer&)
static U32 TmIo::sCommThreadFunc(TmIo*)
zD/proc/%i/exe
/proc/self/cmdline
lsof -p %d
%s|%d
%s %s %s %s %s %s %s %s %s
<unnamed>
*** WARNING: String table too small, overflow!!! ***
rrSocket: socket() failed with error %d
setsockopt(SO_SNDBUF): failed with error %d
setsockopt(SO_RCVBUF): failed with error %d
rrSocket: send failure, would block
rrSocket: send failure, out of buffer space
rrSocket: send failure, connection was reset
rrSocket: send failure, not socket
rrSocket: send failure, connection aborted
rrSocket: send failure, ENOTCONN
rrSocket: send failure, error = %d
rrSocket: connect() failed (%d)
rrSocket: select() failed (%d)
rrSockett: getsockopt reported %d while getting connection status
rrSocket: error when recving, errno = 0x%x
rrSocket: could not bind socket (0x%x)
rrSocket: accept failed with error 0x%x
rrSocketStartup!
gethostbyname failed
getifaddrs
;*2$"
GCC: (Ubuntu/Linaro 4.6.4-1ubuntu1~12.04) 4.6.4
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rel.dyn
.rel.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.ctors
.dtors
.dynamic
.got.plt
.data
.comment
