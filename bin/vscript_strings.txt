__gmon_start__
_init
_fini
__cxa_finalize
_Jv_RegisterClasses
Plat_IsInDebugSession
WriteMiniDump
Plat_ExitProcess
g_pMemAlloc
memset
strlen
memcpy
strchr
wcslen
wcschr
__cxa_atexit
RandomFloat
RandomInt
_ZTVN10__cxxabiv120__si_class_type_infoE
_ZTVN10__cxxabiv117__class_type_infoE
Plat_FloatTime
_Z6DevMsgPKcz
Error
Plat_MSTime
Warning
_Z10DevWarningPKcz
strtol
strtoul
strtod
strtoll
memmove
strstr
toupper
tolower
vsprintf
longjmp
_setjmp
isxdigit
isalnum
isalpha
iscntrl
strcmp
socket
select
listen
accept
strcpy
ThreadSleep
pthread_cancel
malloc
atan2
atanf
log10f
acosf
asinf
srand
ispunct
isspace
islower
isupper
isprint
strtok
vsnprintf
sscanf
_Z6ConMsgPKcz
_ZTVN10__cxxabiv121__vmi_class_type_infoE
dlopen
dlerror
CommandLine
s_pInterfaceRegs
CreateInterface
dlclose
dlsym
getcwd
strnlen
strcasecmp
towupper
towlower
wcsncpy
vswprintf
strncat
wcsncat
mbstowcs
wcstombs
iconv_open
iconv
iconv_close
LOG_GENERAL
LoggingSystem_IsChannelEnabled
LoggingSystem_Log
chdir
iswalnum
iswspace
strtoull
iswalpha
atan2f
sincosf
GetCPUInformation
RandomSeed
cbrtf
libtier0.so
libvstdlib.so
libm.so.6
libdl.so.2
strerror
memcmp
memchr
_ZTVN9__gnu_cxx24__concurrence_lock_errorE
_ZTVN9__gnu_cxx26__concurrence_unlock_errorE
_ZTIN9__gnu_cxx24__concurrence_lock_errorE
_ZTIN9__gnu_cxx26__concurrence_unlock_errorE
_ZTSN9__gnu_cxx24__concurrence_lock_errorE
_ZTSN9__gnu_cxx26__concurrence_unlock_errorE
pthread_mutex_lock
pthread_mutex_unlock
abort
_ZTIN10__cxxabiv115__forced_unwindE
_ZTIN10__cxxabiv119__foreign_exceptionE
_ZTVN10__cxxabiv115__forced_unwindE
_ZTVN10__cxxabiv119__foreign_exceptionE
_ZTSN10__cxxabiv115__forced_unwindE
_ZTSN10__cxxabiv119__foreign_exceptionE
syscall
_ZTVN9__gnu_cxx20recursive_init_errorE
_ZTIN9__gnu_cxx20recursive_init_errorE
___tls_get_addr
_ZTSN9__gnu_cxx20recursive_init_errorE
pthread_cond_broadcast
pthread_cond_signal
pthread_cond_wait
pthread_cond_destroy
stderr
fputs
fputc
realloc
strncmp
libpthread.so.0
ld-linux.so.2
pthread_once
dl_iterate_phdr
libc.so.6
_edata
__bss_start
GLIBC_2.1
GLIBC_2.0
GLIBC_2.3
GLIBC_2.3.2
GLIBC_2.2.4
GLIBC_2.2
GLIBC_2.1.3
<[^_]
<[^_]
tA~G=
,[^_]
,[^_]
,[^_]
<[^_]
L[^_]
<[^_]
<[^_]
<[^_]
,[^_]
9_<~*
L[^_]
L[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
,[^_]
u)+C 
,[^_]
,[^_]
,[^_]
It~"1
9^p~,
,[^_]
,[^_]
,[^_]
-VUUU
,[^_]
,[^_]
-VUUU
<[^_]
-VUUU
<[^_]
<[^_]
f;2t{
,[^_]
<[^_]
<[^_]
<[^_]
<[^_]
,[^_]
,[^_]
<[^_]
<[^_]
L[^_]
L[^_]
<[^_]
<[^_]
\[^_]
\[^_]
\[^_]
,[^_]
F8+F<
9S vZ
,[^_]
P8+P<
<[^_]
<[^_]
B8+B<
^8+^<9
C8+C<
<[^_]
<[^_]
,[^_]
L[^_]
C8+C<
<[^_]
<[^_]
9XLtK
B8+B<
F8+F<
;x v;
C8+C<
F8+F<
<[^_]
L[^_]
L[^_]
9Z,v+
9x,w)
<[^_]
<[^_]
tg~E=
<[^_]
<[^_]
\[^_]
\[^_]
v,;s0
;{$v<
|[^_]
|[^_]
[,;^0
<[^_]
;~$v;
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
L[^_]
L[^_]
<[^_]
;p v6
<[^_]
;_ v6
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
9^<~p
\[^_]
\[^_]
;K v?
,[^_]
,[^_]
L[^_]
l[^_]
l[^_]
S$9S(
S09S4
,[^_]
,[^_]
,[^_]
,[^_]
R$;V(
l[^_]
@0;F4
@<;F@
V@9VD
<[^_]
L[^_]
L[^_]
L[^_]
<[^_]
\[^_]
\[^_]
\[^_]
{h9{l
~d9N,
}tL=,
~d9N8v`
)th=8
)te=8
N@9ND
,[^_]
,[^_]
\[^_]
\[^_]
,[^_]
L[^_]
L[^_]
<[^_]
SX9S\
SL9SPvG
9~@vX
9~LvX
9~pvV
,[^_]
,[^_]
9s4~8
9s<~8
9sD~8
9CL~K
9s$~5
,[^_]
<*t(w
{89{<
{89{<
s89s<
<[^_]
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
,[^_]
{89{<
{89{<w
{89{<
<[^_]
<[^_]
s89s<vf
s89s<
s89s<v7
s89s<w
t;9{<w
s89s<
{8;{<
<=tV<>
,[^_]
,[^_]
K09K4w
L[^_]
K<;Cp
V,9K4vj
S0f+P,f
|[^_]
<[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
HT~*1
<[^_]
L[^_]
L[^_]
tK~)= 
t>~$= 
,[^_]
,[^_]
<[^_]
<[^_]
,[^_]
<[^_]
<[^_]
,[^_]
9S tX
,[^_]
<[^_]
<[^_]
,[^_]
,[^_]
\[^_]
\[^_]
,[^_]
,[^_]
9{$~Q
,[^_]
;{$}Q
,[^_]
\[^_]
;_8|@
;~(v0
,[^_]
,[^_]
,[^_]
Fl;Fp
9C w/
K,9K0
C,9C0
\[^_]
\[^_]
\[^_]
L[^_]
9S\t3
,[^_]
s 9K4
Cl;Cp
S0f+P,f
,[^_]
\[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
\[^_]
\[^_]
L[^_]
L[^_]
<[^_]
<[^_]
vGf=sr
wvf=so
v|f=di
f=siu
f=tru
<[^_]
<[^_]
,[^_]
\[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
,[^_]
,[^_]
,[^_]
E<3w@
l[^_]
C$;S(~&
,[^_]
<[^_]
,[^_]
,[^_]
L[^_]
L[^_]
<[^_]
<[^_]
L[^_]
,[^_]
,[^_]
<[^_]
,[^_]
<.t.<\urf
,[^_]
t)<.u
,[^_]
<[^_]
<[^_]
,[^_]
<[^_]
<[^_]
L[^_]
L[^_]
L[^_]
,[^_]
,[^_]
,[^_]
	vI<-tE<_tA<.t=
,[^_]
tc<?t_
,[^_]
,[^_]
<[^_]
<[^_]
,[^_]
,[^_]
<?t5<.t1<!t-
$[^_]
<[^_]
<[^_]
<[^_]
<[^_]
X[^_]
<[^_]
<[^_]
<[^_]
X[^_]
<[^_]
X[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
L[^_]
L[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
L[^_]
L[^_]
L[^_]
L[^_]
L[^_]
L[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
L[^_]
<[^_]
<[^_]
<[^_]
,[^_]
,[^_]
,[^_]
,[^_]
L[^_]
L[^_]
L[^_]
L[^_]
L[^_]
L[^_]
,[^_]
,[^_]
,[^_]
<[^_]
<[^_]
,[^_]
,[^_]
,[^_]
<[^_]
+C ;C
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
Y-\x	
l[^_]
l[^_]
|[^_]
|[^_]
([^_]
 [^_]
d[^_]
d[^_]
0[^_]
0[^_]
 [^_]
/%Xy	
X%`y	
Y%hy	
h[^_]
h[^_]
h[^_]
h[^_]
,[^_]
|[^_]
` [^_]
|[^_]
?[^_]
|[^_]
|[^_]
l[^_]
L[^_]
Y%xx	
|[^_]
Ph0~	
XZ[^_]
[[^_]
"VVh:
.QVWP
~1PPVS
WQRVS
2ZY^_]
,[^_]
@4CUNG
Z[^_]
8Tu0@
	~JPj
q ;q$}
:Eu	B
0<	w(
tLRRj
0<	w8
<Lt#<Xt
:EuWB
t4RRj
<Itn<J
<Tt7<V
<htq<v
t!RRPV
tu<Etq
t.RRj
ZtiWj
2ZY^_]
,[^_]
Ac@tr
t,QQVW
WVSRP
WVSRP
WVSRP
WVSRP
u4PPW
2ZY^_]
,[^_]
~	zuf
QQWR1
vscript
Generate a random floating point number within a range, inclusive
Generate a random integer within a range, inclusive
RandomFloat
RandomInt
VScriptManager009
23CSplitScreenAddedConVar
14CScriptManager
15CTier1AppSystemI14IScriptManagerLi0EE
15CTier0AppSystemI14IScriptManagerE
14CBaseAppSystemI14IScriptManagerE
14IScriptManager
10IAppSystem
FLOAT
INTEGER
TABLE
ARRAY
NATIVECLOSURE
USERDATA
GENERATOR
THREAD
USERPOINTER
CLASS
INSTANCE
WEAKREF
<unknown>
Squirrel
unnamed
%x%x%llx_%s
function 
<unnamed>
Vector
null vector
Internal error
RegisterFunctionDocumentation
%s [%d]
(instance : 0x%p)
%f %f %f))
(vector : (%f, %f, %f))
Vector argument expected
Accessed null instance
CUtlFixedMemory overflow!
developer
constructor
_tostring
IsValid
CUtlRBTree overflow!
Incompatible script version
GetFunctionSignature
VSquirrel_OnCreateScope
VSquirrel_OnReleaseScope
_typeof
_nexti
ToKVString
Length
LengthSqr
Length2D
Length2DSqr
Cross
handle
Script running too long, terminating
GenerateUniqueKey: buffer too small
NULL instance passed to vscript!
Invalid scope handed to script VM
Callstack mismatch in VScript/Squirrel!
FmtStrVSNPrintf truncated to %d without QUIET_TRUNCATION specified!
CUtlLinkedList overflow! (exhausted index range)
CUtlLinkedList overflow! (exhausted memory allocator)
Save load of generators not well tested. caveat emptor
Failed to restore a Squirrel object of type %s
Failed to read Squirrel table entry %s
8CFmtStrNILi256ELb0EE
9IScriptVM
11CSquirrelVM
ZN11CSquirrelVM9DumpStateEvE9CIterator
13SQCollectable
16CSQStateIterator
?wrong argument type, expected '%s' got '%.50s'
not enough params in the stack
rawset works only on array/table/class and instance
the object is not a class instance
the object is not a nativeclosure
rawget works only on array/table/instance and class
clear only works on table and array
only generators can be resumed
cannot resume a vm that is not running any code
the type doesn't have a default delegate
the index doesn't exist
wrong type
null key
null is not a valid key
invalid type tag
the object is not a class
the class is locked
invalid object type
ivalid type, expected table
ivalid type
invalid param type
invalid base type
unexpected type %s
delagate cycle
the object is not a closure
negative size
io error
invalid stream
invalid free var index
wrong index
the object must be a weakref
cannot iterate a generator
the target is not a closure
invalid environment
native closure expected
invalid typemask
invalid param
unnamedbuffer
unknown
locals
running
suspended
internal VM error
assertion failed
top() on a empty array
cannot wakeup a idle thread
wrong parameter
wrong indexes
slice out of range
size must be a number
idx out of range
cannot convert the string
seterrorhandler
_version_
Squirrel 2.2.3 stable
_charsize_
_intsize_
_floatsize_
compare func failed
native
varargs
paramscheck
typecheck
getclass
rawin
getattributes
setattributes
wakeup
getstatus
pcall
pacall
bindenv
c x|y|t
getinfos
tointeger
tofloat
tochar
slice
 s n  n
s s n 
tolower
toupper
extend
remove
reverse
clear
rawget
rawset
rawdelete
setdebughook
enabledebuginfo
getstackinfos
getroottable
setroottable
getconsttable
setconsttable
assert
print
compilestring
newthread
suspend
dummy
collectgarbage
cannot wakeup a running thread
Invalid qsort, probably compare function defect
7SQClass
10SQInstance
IDENTIFIER
STRING_LITERAL
expected '%s'
expected '%c'
expected ')'
expected '='
expected ')' or ','
invalid constant [%s.%s]
can't delete an expression
cannot delete a local
expression expected
parent cannot be set
can't assign expression
can't 'create' a local slot
invalid class name
@INDEX@
@ITERATOR@
scalar expected : integer,float
scalar expected : integer,float or string
function with default parameters cannot have variable number of parameters
cannot brake deref/or comma needed after [exp]=exp slot declaration
expression expected, found ')'
free variables cannot be modified
'break' has to be in a loop block
'continue' has to be in a loop block
cannot create a class in a local with the syntax(class <local>)
end of statement expected (; or lf)
NATIVE
%.14g
the index '%.50s' does not exist
comparsion between '%.50s' and '%.50s'
parameter %d has an invalid type '%s' ; expected: '%s'
false
(%s %p)
internal compiler error: too many locals
15SQFunctionProto
Invalid character
while
break
continue
foreach
catch
throw
clone
yield
resume
switch
default
parent
extends
instanceof
vargc
vargv
static
missing "*/" in comment
unfinished string
newline in a constant
hexadecimal number expected
unrecognised escaper char
empty constant
constant too long
invalid octal number
invalid numeric format
exponent expected
string expected
error parsing the string
invalid token '..'
unexpected character(control)
too many digits for an Hex number
_delegate 
native function
userdata
resuming dead generator
resuming active generator
cannot serialize a %s
_lasterror
_errorhandler
_debughook
_roottable
temp_reg
_stack
_vargsstack
_members
_base 
_attributes
_defaultvalues
_methods
_metamethods
_class 
internal vm error, yielding dead generator
internal vm error, yielding a dead generator
io error (write function failure)
io error, read function failure, the origin stream could be corrupted/trucated
invalid or corrupted closure stream
12SQRefCounted
9SQWeakRef
11SQDelegable
8SQString
7SQArray
10SQUserData
9SQClosure
11SQGenerator
15SQNativeClosure
_registry
_consts
_metamethodsmap
_table_default_delegate
_array_default_delegate
_string_default_delegate
_number_default_delegate
_generator_default_delegate
_thread_default_delegate
_closure_default_delegate
_class_default_delegate
_instance_default_delegate
_weakref_default_delegate
userpointer
_modulo
_call
_cloned
_newslot
_delslot
_newmember
_inherited
7SQTable
internal vm error bitwise op failed
bitwise op between '%s' and '%s'
cannot suspend an already suspended vm
cannot suspend through native calls/metamethods
the function doesn't have var args
the %s type doesn't have a parent slot
Script terminated by SQQuerySuspend
cannot apply instanceof between a %s and a %s
attempt to perform a bitwise op on a %s
trying to yield a '%s',only genenerator can be yielded
trying to resume a '%s',only genenerator can be resumed
attempt to delete a slot from a %s
class instances do not support the new slot operator
trying to modify a class that has already been instantiated
the property '%s' already exists
_nexti returned an invalid idx
arith op %c on between '%s' and '%s' (%s)
arith op %c on between '%s' and '%s'
delegating a '%s'
delegate cycle detected
using '%s' as delegate
indexing 'vargv' with %s
vargv index out of range
Native stack overflow
wrong number of parameters
terminated by debugger
attempt to call '%s'
cloning a %s
cannot delete a slot from %s
null cannot be used as index
indexing %s with %s
trying to set '%s'
_nexti failed
cannot iterate %s
(weakref : 0x%p [%s] )
(%s : 0x%p)
attempt to negate a %s
division by zero
modulo by zero
trying to inherit from a %s
4SQVM
pAfailed to bind the socket
disconnected
socket error
SERIALIZE_STATE
error on listen(socket)
error accept(socket)
socket failed
*FUNCTION [%s] %s line [%d]
AN ERROR HAS OCCURED [%s]
failed to initialize the debugger
error compiling the serialization function
AN ERROR HAS OCCURED [unknown]
	see copyright notice in sqrdbg.h
local currentscope;
if ( ::getroottable().parent )
	currentscope = ::getroottable();
	::setroottable( ::getroottable().parent );
try {
local objs_reg = { maxid=0 ,refs={} }
complex_types <- {
	["table"] = null,
	["array"] = null,
	["class"] = null,
	["instance"] = null,
	["weakref"] = null,
function build_refs(t):(objs_reg)
	if(t == ::getroottable())
		return;
	local otype = ::type(t);
	if(otype in complex_types)
		if(!(t in objs_reg.refs)) {
			objs_reg.refs[t] <- objs_reg.maxid++;
		    iterateobject(t,function(o,i,val):(objs_reg)
		    {
			    build_refs(val);
			    build_refs(i);
		    })
function getvalue(v):(objs_reg)
	switch(::type(v))
		case "table":
		case "array":
		case "class":
		case "instance":
			return objs_reg.refs[v].tostring();
		case "integer":
		case "float":
		    return v;
		case "bool":
		    return v.tostring();
		case "string":
			return v;
		case "null":
		    return "null";
		default:
			return pack_type(::type(v));
local packed_types={
	["null"]="n",
	["string"]="s",
	["integer"]="i",
	["float"]="f",
	["userdata"]="u",
	["function"]="fn",
	["table"]="t",
	["array"]="a",
	["generator"]="g",
	["thread"]="h",
	["instance"]="x", 
	["class"]="y",  
	["bool"]="b",
	["weakref"]="w"  
function pack_type(type):(packed_types)
	if(type in packed_types)return packed_types[type]
	return type
function iterateobject(obj,func)
	local ty = ::type(obj);
	if(ty == "instance") {
		try { //TRY TO USE _nexti
		    foreach(idx,val in obj)
		    {
				func(obj,idx,val);
		    }
		catch(e) {
		   foreach(idx,val in obj.getclass())
		   {
			func(obj,idx,obj[idx]);
		   }
	else if(ty == "weakref") {
		func(obj,"@ref",obj.ref());
	else {
		foreach(idx,val in obj)
		    func(obj,idx,val);
function build_tree():(objs_reg)
	foreach(i,o in objs_reg.refs)
		beginelement("o");
		attribute("type",(i==::getroottable()?"r":pack_type(::type(i))));
		local _typeof = typeof i;
		if(_typeof != ::type(i)) {
			attribute("typeof",_typeof);
		attribute("ref",o.tostring());
		if(i != ::getroottable()){
			iterateobject(i,function (obj,idx,val) {
				if(::type(val) == "function")
					return;
					
				if ( ::type(idx) == "string" && idx.find( "__" ) == 0 )
					return;
				beginelement("e");	
					emitvalue("kt","kv",idx);
					emitvalue("vt","v",obj[idx]);
				endelement("e");	
			})
		endelement("o");
function evaluate_watch(locals,id,expression)
	local func_src="return function ("
	local params=[];
	params.append(locals["this"])
	local first=1;
	foreach(i,v in locals){
		if(i!="this" && i[0] != '@'){ //foreach iterators start with @
			if(!first){
				func_src=func_src+","
			first=null
			params.append(v)
			func_src=func_src+i
	func_src=func_src+"){\n"
	func_src=func_src+"return ("+expression+")\n}"
	try {
		local func=::compilestring(func_src);
		return {status="ok" , val=func().acall(params)};
	catch(e)
		return {status="error"}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
function emitvalue(type_attrib,value_attrib,val)
	attribute(type_attrib,pack_type(::type(val)));
	attribute(value_attrib,getvalue(val).tostring());
local stack=[]
local level=3;
local si;
	//ENUMERATE THE STACK WATCHES
	while(si=::getstackinfos(level))
		stack.append(si);
		level++;
	//EVALUATE ALL WATCHES
	objs_reg.refs[::getroottable()] <- objs_reg.maxid++;
	foreach(i,val in stack)
		if(val.src!="NATIVE") {
			if("watches" in this) {
				val.watches <- {}
				foreach(i,watch in watches)
				{
					if(val.src!="NATIVE"){
						val.watches[i] <- evaluate_watch(val.locals,i,watch);
						if(val.watches[i].status!="error")
							build_refs(val.watches[i].val);
					}
					else{
						val.watches[i] <- {status="error"}
					}
					val.watches[i].exp <- watch;
				}
		foreach(i,l in val.locals)
			build_refs(l);
	beginelement("objs");
	build_tree();
	endelement("objs");
	beginelement("calls");
	foreach(i,val in stack)
		beginelement("call");
		attribute("fnc",val.func);
		attribute("src",val.src);
		attribute("line",val.line.tostring());
		foreach(i,v in val.locals)
			beginelement("l");
				attribute("name",getvalue(i).tostring());
				emitvalue("type","val",v);
			endelement("l");
		if("watches" in val) {
			foreach(i,v in val.watches)
				beginelement("w");
					attribute("id",i.tostring());
					attribute("exp",v.exp);
					attribute("status",v.status);
					if(v.status!="error") {
						emitvalue("type","val",v.val);
					}
				endelement("w");
		endelement("call");
	endelement("calls");
	objs_reg = null;
	stack = null;
	if("collectgarbage" in ::getroottable()) ::collectgarbage();
}catch(e)
	::print("ERROR"+e+"\n");
if ( currentscope )
	::setroottable( currentscope );
Script debugger disconnected
_sqdbg_debug_hook_
_sqdbg_error_handler_
watches
beginelement
endelement
attribute
vector::_M_default_append
</%s>
terminated
 %s="%s"
the breakpoint doesn't exists
removebreakpoint
the watch does not exists
removed watch %d
addbreakpoint
added bp %d %s
error parsing add breakpoint
removed bp %d %s
resumed
go (execution resumed)
step into
step return
disabled
added watch %d %s
error parsing add watch
added watch %d
error parsing remove watch
terminate from user
ready
unknown packet
&amp;
&apos;
&quot;
&quot;n
&quot;r
error parsing remove breakpoint
%s line = (%d) column = (%d) : error %s
*FUNCTION [%s()] %s line [%d]
AN ERROR HAS OCCURED [unknown]
CALLSTACK
LOCALS
[%s] NULL
[%s] %d
[%s] %.14g
[%s] USERPOINTER
[%s] "%s"
[%s] TABLE
[%s] ARRAY
[%s] CLOSURE
[%s] NATIVECLOSURE
[%s] GENERATOR
[%s] USERDATA
[%s] THREAD
[%s] CLASS
[%s] INSTANCE
[%s] WEAKREF
[%s] %s
internal error (_nexti) wrong argument type
cannot create blob with negative size
resize failed
std_blob
swap2
swap4
casti2f
castf2i
swapfloat
8SQStream
6SQBlob
RAND_MAX
log10
atan2
floor
srand
overflow in numeric constant
letter expected
expected paren
empty class
invalid range
, or } expected
unexpected character
cannot use character classes in ranges
the stream is invalid
invalid origin
invalid format
invalid parameter
no data left to read
std_stream
table expected
readblob
readn
writeblob
writen
flush
regexp
empty separators string
begin
-+ #0
width format too long
precision format too long
search
match
capture
subexpcount
lstrip
rstrip
split
not enough paramters for the given format string
string expected for the specified format
integer expected for the specified format
float expected for the specified format
getVar(): Could not create instance: %s
getVar(): Invalid type+access: 'ScriptStringVarBase' with VAR_ACCESS_CONSTANT (use VAR_ACCESS_READ_ONLY instead)
getVar(): Invalid type+access: 'const SQChar *' without VAR_ACCESS_CONSTANT
getVarInfo: Could not retrieve UserData
getInstanceVarInfo: Could not retrieve UserData
setVar(): Cannot write to constant: %s
INSTANCE type assignment mismatch
setVar(): Cannot write to an SQUserPointer: %s
Invalid Instance Type
13SquirrelError
__SqTypes
14SquirrelObject
unknown error
call already initialized
call not initialized
t|y|x%s
t|y|x
CreateFunction: typeMask string too long.
{}()':
%i %i %i %i
FCVAR_NEVER_AS_STRING
"%s" = "%s"
 ( def. "%s" )
 min. %f
 max. %f
"%s" 
%-80s - %.80s
%-80s
client
archive
notify
singleplayer
notconnected
cheat
replicated
server_can_execute
clientcmd_can_execute
ss_added
CCommand::Tokenize: Encountered command which overflows the tokenizer buffer.. Skipping!
CCommand::Tokenize: Encountered command which overflows the argument buffer.. Clamped!
Warning:  %s = '%s' is infinite, clamping value.
ConVarRef %s doesn't point to an existing ConVar
 [%.3f server clamped to %.3f]
ConVar(%s) defined with infinite float value (%s)
InstallChangeCallback called with NULL callback, ignoring!!!
InstallChangeCallback ignoring duplicate change callback!!!
14ConCommandBase
10ConCommand
6ConVar
20ConVar_ServerBounded
7IConVar
12CEmptyConVar
16CDefaultAccessor
23IConCommandBaseAccessor
No such file
image not found
_xlsp
_valveinternal
-xlsp
-valveinternal
DLOPEN Error:%s
%s/%s
%s/bin/%s
BuiltDebug
-allowdebug
Module %s is a debug build
CreateInterface
 failed to dlopen %s error=%s
16CDllDemandLoader
 bytes
%%.%if%s
,%03d
UCS-2LE
UCS-4LE
UTF-32LE
UTF-8
0123456789ABCDEF
[url=
steam://openurl/
steam://openurl_external/
%s %s %s %s
</script>
&#92;
&#36;
&#35;
&nbsp;
&trade;
&copy;
&reg;
&ndash;
&mdash;
&euro;
&iexcl;
&cent;
&pound;
&curren;
&yen;
&brvbar;
&sect;
&uml;
&ordf;
&laquo;
&not;
&shy;
&macr;
&deg;
&plusmn;
&sup2;
&sup3;
&acute;
&micro;
&para;
&middot;
&cedil;
&sup1;
&ordm;
&raquo;
&frac14;
&frac12;
&frac34;
&iquest;
&times;
&divide;
&Agrave;
&Aacute;
&Acirc;
&Atilde;
&Auml;
&Aring;
&AElig;
&Ccedil;
&Egrave;
&Eacute;
&Ecirc;
&Euml;
&Igrave;
&Iacute;
&Icirc;
&Iuml;
&ETH;
&Ntilde;
&Ograve;
&Oacute;
&Ocirc;
&Otilde;
&Ouml;
&Oslash;
&Ugrave;
&Uacute;
&Ucirc;
&Uuml;
&Yacute;
&THORN;
&szlig;
&agrave;
&aacute;
&acirc;
&atilde;
&auml;
&aring;
&aelig;
&ccedil;
&egrave;
&eacute;
&ecirc;
&euml;
&igrave;
&iacute;
&icirc;
&iuml;
&eth;
&ntilde;
&ograve;
&oacute;
&ocirc;
&otilde;
&ouml;
&oslash;
&ugrave;
&uacute;
&ucirc;
&uuml;
&yacute;
&thorn;
&yuml;
[code]
<pre>
[/code]
</pre>
[/h1]
</h1>
[list]
[/list]
</ul>
[/url]
[img]
<img src="
[/img]
"></img>
V_AppendSlash: ran out of space on %s.
V_MakeAbsolutePath: _getcwd failed.
0123456789ABCDEF$
0123456789abcdef
?0,/1a,
-&B'-
,/$`,
CUtlBuffer::VaPrintf: String overflowed buffer [%d]
18CUtlCharConversion
21CUtlCStringConversion
19CUtlNoEscConversion
APPSYSTEM: In ConnectInterfaces(), s_nRegistrationCount is %d!
Physics2 Interface ActorMgr v0.1
Physics2 Interface ResourceMgr v0.1
MaterialSystemHardwareConfig013
VEngineCvar007
EventSystem001
VProcessUtils002
Physics2 Interface v0.3
VFileSystem017
VNewAsyncFileSystem001
ResourceSystem004
VMaterialSystem080
VMaterialSystem2_001
InputSystemVersion001
InputStackSystemVersion001
NetworkSystemVersion001
RenderDeviceMgr001
SoundSystem001
DebugTextureInfo001
VBAllocTracker001
COLORCORRECTION_VERSION_1
VP4002
VMDLLIB001
QueuedLoaderVersion001
VResourceAccessControl001
VPrecacheSystem001
VStudioRender026
VGUI_ivgui008
VGUI_Input005
VGUI_Panel009
VGUI_Surface031
VGUI_Scheme010
VGUI_System010
Localize_001
MatSystemSurface006
VDataCache003
MDLCache004
VAvi001
VBik001
VDmeMakeFileUtils001
VPhysicsCollision007
VSoundEmitter003
MeshSystem001
RenderDevice001
RenderHardwareConfig001
SceneSystem_001
WorldRendererMgr001
RenderSystemSurface001
MATCHFRAMEWORK_001
GameUISystemMgr001
SSE and SSE2 are required.
'_? A1> A1> A1> A1>
4fff>fff>fff>fff>
?333333
C33s?
Dstd::future_error
St17bad_function_call
NSt8ios_base7failureE
St11logic_error
St12domain_error
St16invalid_argument
St12length_error
St12out_of_range
St13runtime_error
St11range_error
St14overflow_error
St15underflow_error
generic
system
St14error_category
St12system_error
N12_GLOBAL__N_122generic_error_categoryE
N12_GLOBAL__N_121system_error_categoryE
regex_error
St11regex_error
future
Broken promise
Future already retrieved
Promise already satisfied
No associated state
Unknown error
St12future_error
NSt13__future_base12_Result_baseE
NSt13__future_base11_State_baseE
N12_GLOBAL__N_121future_error_categoryE
basic_string::at
basic_string::copy
basic_string::compare
basic_string::_S_create
basic_string::assign
basic_string::_M_replace_aux
basic_string::replace
basic_string::insert
basic_string::erase
basic_string::append
basic_string::resize
basic_string::_S_construct null not valid
basic_string::basic_string
basic_string::substr
__gnu_cxx::__concurrence_lock_error
__gnu_cxx::__concurrence_unlock_error
N9__gnu_cxx24__concurrence_lock_errorE
N9__gnu_cxx26__concurrence_unlock_errorE
std::bad_typeid
St10bad_typeid
std::exception
std::bad_exception
St9exception
St13bad_exception
N10__cxxabiv115__forced_unwindE
N10__cxxabiv119__foreign_exceptionE
std::bad_cast
St8bad_cast
std::bad_alloc
St9bad_alloc
N9__gnu_cxx20recursive_init_errorE
terminate called recursively
terminate called after throwing an instance of '
terminate called without an active exception
  what():  
_GLOBAL_
(anonymous namespace)
string literal
JArray
VTT for 
construction vtable for 
typeinfo for 
typeinfo name for 
typeinfo fn for 
non-virtual thunk to 
covariant return thunk to 
java Class for 
guard variable for 
reference temporary for 
hidden alias for 
_Sat 
_Accum
_Fract
operator
operator 
java resource 
decltype (
{parm#
global constructors keyed to 
global destructors keyed to 
{lambda(
{unnamed type#
 restrict
 volatile
 const
complex 
imaginary 
 __vector(
{default arg#
boolean
long double
__float128
unsigned char
unsigned int
unsigned
unsigned long
unsigned __int128
unsigned short
wchar_t
unsigned long long
decimal32
decimal64
decimal128
char16_t
char32_t
decltype(nullptr)
std::allocator
std::basic_string
std::string
std::basic_string<char, std::char_traits<char>, std::allocator<char> >
std::istream
std::basic_istream<char, std::char_traits<char> >
basic_istream
std::ostream
std::basic_ostream<char, std::char_traits<char> >
basic_ostream
std::iostream
std::basic_iostream<char, std::char_traits<char> >
basic_iostream
delete[]
new[]
sizeof 
alignof 
A. H.
C. H.
A. H.
A. H.
D. C.
A. G.
A. I.
A. F.
E. H.
B. O.
B. G.
B. K.
B. E.
//===	======= Copyright 
 2008, Valve Corporation, All rights reserved. ========
// Purpose: Script initially run after squirrel VM is initialized
//=============================================================================
//-----------------------------------------------------------------------------
// General
//-----------------------------------------------------------------------------
function printl( text )
	return print( text + "\n" );
function Msg( text )
	return print( text );
function Assert( b, msg = null )
	if ( b )
		return;
	if ( msg != null )
		throw "Assertion failed: " + msg;
	else
		throw "Assertion failed";
//-----------------------------------------------------------------------------
// Documentation table
//-----------------------------------------------------------------------------
if ( developer() > 0 )
	Documentation <-
		classes = {}
		functions = {}
		instances = {}
	function RetrieveNativeSignature( nativeFunction )
		if ( nativeFunction in NativeFunctionSignatures )
			return NativeFunctionSignatures[nativeFunction]
		return "<unnamed>"
	function RegisterFunctionDocumentation( func, name, signature, description )
		if ( description.len() )
			local b = ( description[0] == '#' );
			if ( description[0] == '#' )
				local colon = description.find( ":" );
				if ( colon == null )
				{
					colon = description.len();
				}
				local alias = description.slice( 1, colon );
				description = description.slice( colon + 1 );
				name = alias;
				signature = "#";
		Documentation.functions[name] <- [ signature, description ]
	function Document( symbolOrTable, itemIfSymbol = null, descriptionIfSymbol = null )
		if ( typeof( symbolOrTable ) == "table" )
			foreach( symbol, itemDescription in symbolOrTable )
				Assert( typeof(symbol) == "string" )
				Document( symbol, itemDescription[0], itemDescription[1] );
		else
			printl( symbolOrTable + ":" + itemIfSymbol.tostring() + "/" + descriptionIfSymbol );
	function PrintHelp( string = "*", exact = false )
		local matches = []
		if ( string == "*" || !exact )
			foreach( name, documentation in Documentation.functions )
				if ( string != "*" && name.tolower().find( string.tolower() ) == null )
				{
					continue;
				}
				matches.append( name ); 
		else if ( exact )
			if ( string in Documentation.functions )
				matches.append( string )
		if ( matches.len() == 0 )
			printl( "Symbol " + string + " not found" );
			return;
		matches.sort();
		foreach( name in matches )
			local result = name;
			local documentation = Documentation.functions[name];
			printl( "Function:    " + name );
			local signature;
			if ( documentation[0] != "#" )
				signature = documentation[0];
			else
				signature = GetFunctionSignature( this[name], name );
			printl( "Signature:   " + signature );
			if ( documentation[1].len() )
				printl( "Description: " + documentation[1] );
			print( "\n" ); 
	function RetrieveNativeSignature( nativeFunction ) { return "<unnamed>"; }
	function Document( symbolOrTable, itemIfSymbol = null, descriptionIfSymbol = null ) {}
	function PrintHelp( string = "*", exact = false ) {}
//-----------------------------------------------------------------------------
// VSquirrel support functions
//-----------------------------------------------------------------------------
function VSquirrel_OnCreateScope( name, outer )
	local result;
	if ( !(name in outer) )
		result = outer[name] <- { __vname=name, __vrefs = 1 };
		delegate outer : result;
	else
		result = outer[name];
		result.(void, long double,...)(float, short) += 1;
	return result;
function VSquirrel_OnReleaseScope( scope )
	scope.(void, long double,...)(float, short) -= 1;
	if ( scope.(void, long double,...)(float, short) < 0 )
		throw "Bad reference counting on scope " + scope.__vname;
	else if ( scope.(void, long double,...)(float, short) == 0 )
		delete scope.parent[scope.__vname];
		scope.__vname = null;
		delegate null : scope;
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
class CCallChainer
	constructor( prefixString, scopeForThis = null )
		prefix = prefixString;
		if ( scopeForThis != null )
			scope = scopeForThis;
		else
			scope = ::getroottable();
		chains = {};
		// Expose a bound global function to dispatch to this object
		scope[ "Dispatch" + prefixString ] <- Call.bindenv( this );
	function PostScriptExecute() 
		foreach( key, value in scope )
			if ( typeof( value ) == "function" ) 
				if ( key.find( prefix ) == 0 )
				{
					key = key.slice( prefix.len() );
					
					if ( !(key in chains) )
					{
						//::print( "Creating new call chain " + key + "\n");
						chains[key] <- [];
					}
					
					local chain = chains[key];
					
					if ( !chain.len() || chain.top() != value )
					{
						chain.push( value );
						//::print( "Added " + value + " to call chain " + key + "\n" );
					}
				}
	function Call( event, ... )
		if ( event in chains )
			local chain = chains[event];
			if ( chain.len() )
				local i;
				local args = [];
				if ( vargc > 0 )
				{
					args.push( scope );
					for ( i = 0; i < vargc; i++ )
					{
						args.push( vargv[i] );
					}
				}
				for ( i = chain.len() - 1; i >= 0; i -= 1 )
				{
					local func = chain[i];
					local result;
					if ( !args.len() )
					{
						result = func();
					}
					else
					{
						result = func.acall( args ); 
					}
					if ( result != null && !result )
						return false;
				}
		return true;
	scope = null;
	prefix = null;
	chains = null;
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
class CSimpleCallChainer
	constructor( prefixString, scopeForThis = null, exactNameMatch = false )
		prefix = prefixString;
		if ( scopeForThis != null )
			scope = scopeForThis;
		else
			scope = ::getroottable();
		chain = [];
		// Expose a bound global function to dispatch to this object
		scope[ "Dispatch" + prefixString ] <- Call.bindenv( this );
		exactMatch = exactNameMatch
	function PostScriptExecute() 
		foreach( key, value in scope )
			if ( typeof( value ) == "function" ) 
				local foundMatch = false;
				if ( exactMatch )
				{
					foundMatch = ( prefix == key );
				}
				else
				{
					foundMatch = ( key.find( prefix ) == 0 )
				}
						
				if ( foundMatch )
				{
					if ( !exactMatch )
						key = key.slice( prefix.len() );
					
					if ( !(chain) )
					{
						//::print( "Creating new call simple chain\n");
						chain <- [];
					}
					
					if ( !chain.len() || chain != value )
					{
						chain.push( value );
						//::print( "Added " + value + " to call chain.\n" );
					}
				}
	function Call( ... )
		if ( chain.len() )
			local i;
			local args = [];
			if ( vargc > 0 )
				args.push( scope );
				for ( i = 0; i < vargc; i++ )
				{
					args.push( vargv[i] );
				}
			for ( i = chain.len() - 1; i >= 0; i -= 1 )
				local func = chain[i];
				local result;
				if ( !args.len() )
				{
					result = func.pcall( scope );
				}
				else
				{
					result = func.pacall( scope, args ); 
				}
				if ( result != null && !result )
					return false;
		return true;
	exactMatch = false
	scope = null;
	prefix = null;
	chain = null;
//-----------------------------------------------------------------------------
// Late binding: allows a table to refer to parts of itself, it's children,
// it's owner, and then have the references fixed up after it's fully parsed
// Usage:
//    lateBinder <- LateBinder();
//    lateBinder.Begin( this );
//    
//    Test1 <-
//    {   
// 	   Foo=1
//    }   
//    
//    Test2 <-
//    {   
// 	   FooFoo = "I'm foo foo"
// 	   BarBar="@Test1.Foo"
// 	   SubTable = { boo=[bah, "@Test2.FooFoo", "@Test1.Foo"], booboo2={one=bah, two="@Test2.FooFoo", three="@Test1.Foo"} }
// 	   booboo=[bah, "@Test2.FooFoo", "@Test1.Foo"]
// 	   booboo2={one=bah, two="@Test2.FooFoo", three="@Test1.Foo"}
// 	   bah=wha
//    }   
//    
//    lateBinder.End();
//    delete lateBinder;
// When End() is called, all of the unresolved symbols in the tables and arrays will be resolved,
// any left unresolved will become a string prepended with '~', which later code can deal with
//-----------------------------------------------------------------------------
class LateBinder
	// public:
	function Begin( target, log = false )
		m_log = log;
		HookRootMetamethod( "_get", function( key ) { return "^" + key; } );
		HookRootMetamethod( "_newslot", function( key, value ) { if ( typeof value == "table" ) { m_fixupSet.push( [ key, value ] ); this.rawset( key, value ); };  }.bindenv(this) );
		m_targetTable = target;
		Log( "Begin late bind on table " + m_targetTable );
	function End()
		UnhookRootMetamethod( "_get" );
		UnhookRootMetamethod( "_newslot" );
		Log( "End late bind on table " + m_targetTable );
		foreach( subTablePair in m_fixupSet )
			EstablishDelegation( m_targetTable, subTablePair[1] );
		Log( "Begin resolution... " )
		m_logIndent++;
		local found = true;
		while ( found )
			foreach( subTablePair in m_fixupSet )
				Log( subTablePair[0] + " = " );
				Log( "{" );
				if ( !Resolve( subTablePair[1], subTablePair[1], false ) )
				{
					found = false;
				}
				Log( "}" );
		m_logIndent--;
		foreach( subTablePair in m_fixupSet )
			RemoveDelegation( subTablePair[1] );
		Log( "...end resolution" );
	// private:
	function HookRootMetamethod( name, value )
		local saved = null;
		local roottable = getroottable();
		if ( name in roottable )
			saved = roottable[name];
		roottable[name] <- value;
		roottable["__saved" + name] <- saved;
	function UnhookRootMetamethod( name )
		local saveSlot = "__saved" + name;
		local roottable = getroottable();
		local saved = roottable[saveSlot];
		if ( saved != null )
			roottable[name] = saved;
		else
			delete roottable[name];
		delete roottable[saveSlot];
	function EstablishDelegation( parentTable, childTable )
		delegate parentTable : childTable;
		foreach( key, value in childTable )
			local type = typeof value;
			if ( type == "table" )
				EstablishDelegation( childTable, value );
	function RemoveDelegation( childTable )
		delegate null : childTable;
		foreach( key, value in childTable )
			local type = typeof value;
			if ( type == "table" )
				RemoveDelegation( value );
	function Resolve( lookupTable, subTableOrArray, throwException = false )
		m_logIndent++;
		local found = false;
		foreach( key, value in subTableOrArray )
			local type = typeof value;
			if ( type == "string" )
				if ( value.len() )
				{
					local unresolvedId = null;
					local controlChar = value[0]
					if ( controlChar == '^' )
					{
						found = true;
						value = value.slice( 1 );
						if ( value in lookupTable )
						{
							subTableOrArray[key] = lookupTable[value];
							Log( key + " = " + lookupTable[value] + " <-- " + value );
						}
						else
						{
							subTableOrArray[key] = "~" + value;
							unresolvedId = value;
							Log( key + " = \"" + "~" + value + "\" (unresolved)" );
						}
					}
					else if ( controlChar == '@' )
					{
						found = true;
						local identifiers = [];
						local iLast = 1;
						local iNext;
						while ( ( iNext = value.find( ".", iLast ) ) != null )
						{
							identifiers.push( value.slice( iLast, iNext ) );
							iLast = iNext + 1;
						}
						identifiers.push( value.slice( iLast ) );
						
						local depthSuccess = 0;
						local result = lookupTable;
						foreach( identifier in identifiers )
						{
							if ( identifier in result )
							{
								depthSuccess++;
								result = result[identifier];
							}
							else
							{
								break;
							}
						}
						if ( depthSuccess == identifiers.len() )
						{
							subTableOrArray[key] = result;
							Log( key + " = " + result + " <-- " + value );
						}
						else
						{
							subTableOrArray[key] = "~" + value.slice( 1 );
							unresolvedId = value;
							Log( key + " = \"" + "~" + value + "\" (unresolved)" );
						}
					}
					
					if ( unresolvedId != null )
					{
						if ( throwException )
						{
							local exception = "Unresolved symbol: " + bind + " in ";
							foreach ( entry in m_bindNamesStack )
							{
								exception += entry;
								exception += "."
							}
							exception += unresolvedId;
							
							throw exception; 
						}
					}
				}
		foreach( key, value in subTableOrArray )
			local type = typeof value;
			local isTable = ( type == "table" );
			local isArray = ( type == "array" )
			if ( isTable || isArray )
				Log( key + " =" );
				Log( isTable ? "{" : "[" );
				m_bindNamesStack.push( key );
				if ( Resolve( ( isTable ) ? value : lookupTable, value, throwException ) )
				{
					found = true;
				}
				m_bindNamesStack.pop();
				Log( isTable ? "}" : "]" );
		m_logIndent--;
		return found;
	function Log( string )
		if ( m_log )
			for ( local i = 0; i < m_logIndent; i++ )
				print( "  " );
			printl( string );
	m_targetTable = null;
	m_fixupSet = [];
	m_bindNamesStack = [];
	m_log = false;
	m_logIndent = 0;
r""\\
GCC: (crosstool-NG 1.12.2) 4.6.1
.symtab
.strtab
.shstrtab
.note.gnu.build-id
.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rel.dyn
.rel.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.tbss
.ctors
.dtors
.data.rel.ro
.dynamic
.got.plt
.data
.comment
.gnu_debuglink
fputs@@GLIBC_2.0
abort@@GLIBC_2.0
expf@@GLIBC_2.0
pthread_once@@GLIBC_2.0
sprintf@@GLIBC_2.0
_ZTIN9__gnu_cxx20recursive_init_errorE
srand@@GLIBC_2.0
pthread_cond_destroy@@GLIBC_2.3.2
isprint@@GLIBC_2.0
isalpha@@GLIBC_2.0
strerror@@GLIBC_2.0
RandomFloat
__cxa_atexit@@GLIBC_2.1.3
_ZTVN10__cxxabiv119__foreign_exceptionE
tanf@@GLIBC_2.0
memcmp@@GLIBC_2.0
asin@@GLIBC_2.0
wcsncat@@GLIBC_2.0
_ZTIN10__cxxabiv119__foreign_exceptionE
_ZTIN10__cxxabiv115__forced_unwindE
syscall@@GLIBC_2.0
__gmon_start__
_Jv_RegisterClasses
ispunct@@GLIBC_2.0
pthread_cond_signal@@GLIBC_2.3.2
realloc@@GLIBC_2.0
iconv_open@@GLIBC_2.1
isspace@@GLIBC_2.0
vsprintf@@GLIBC_2.0
_ZTIN9__gnu_cxx26__concurrence_unlock_errorE
strtod@@GLIBC_2.0
strchr@@GLIBC_2.0
vsnprintf@@GLIBC_2.0
Plat_MSTime
recv@@GLIBC_2.0
_fini
wcslen@@GLIBC_2.0
pow@@GLIBC_2.0
listen@@GLIBC_2.0
LoggingSystem_Log
dlclose@@GLIBC_2.0
toupper@@GLIBC_2.0
wcschr@@GLIBC_2.0
memset@@GLIBC_2.0
isxdigit@@GLIBC_2.0
_ZTSN9__gnu_cxx20recursive_init_errorE
sincosf@@GLIBC_2.1
RandomInt
_ZTVN10__cxxabiv115__forced_unwindE
iscntrl@@GLIBC_2.0
CreateInterface
strtoll@@GLIBC_2.0
asinf@@GLIBC_2.0
_ZTVN9__gnu_cxx26__concurrence_unlock_errorE
strtol@@GLIBC_2.0
free@@GLIBC_2.0
_Z6DevMsgPKcz
strtoull@@GLIBC_2.0
iswalpha@@GLIBC_2.0
atan@@GLIBC_2.0
cbrtf@@GLIBC_2.0
atanf@@GLIBC_2.0
WriteMiniDump
dlsym@@GLIBC_2.0
accept@@GLIBC_2.0
socket@@GLIBC_2.0
___tls_get_addr@@GLIBC_2.3
GetCPUInformation
pthread_mutex_unlock@@GLIBC_2.0
atan2f@@GLIBC_2.0
_ZTSN10__cxxabiv119__foreign_exceptionE
LoggingSystem_IsChannelEnabled
mbstowcs@@GLIBC_2.0
_setjmp@@GLIBC_2.0
g_pMemAlloc
stderr@@GLIBC_2.0
acos@@GLIBC_2.0
memcpy@@GLIBC_2.0
_ZTVN9__gnu_cxx20recursive_init_errorE
Error
strtoul@@GLIBC_2.0
strlen@@GLIBC_2.0
cosf@@GLIBC_2.0
cos@@GLIBC_2.0
iconv@@GLIBC_2.1
strcpy@@GLIBC_2.0
dlopen@@GLIBC_2.1
longjmp@@GLIBC_2.0
printf@@GLIBC_2.0
chdir@@GLIBC_2.0
bind@@GLIBC_2.0
wcsncpy@@GLIBC_2.0
iswspace@@GLIBC_2.0
strcasecmp@@GLIBC_2.0
log10f@@GLIBC_2.0
select@@GLIBC_2.0
close@@GLIBC_2.0
isalnum@@GLIBC_2.0
strstr@@GLIBC_2.0
acosf@@GLIBC_2.0
_ZTVN10__cxxabiv121__vmi_class_type_infoE
strncat@@GLIBC_2.0
_ZTVN10__cxxabiv117__class_type_infoE
__bss_start
malloc@@GLIBC_2.0
pthread_mutex_lock@@GLIBC_2.0
iswalnum@@GLIBC_2.0
_ZTSN9__gnu_cxx24__concurrence_lock_errorE
isupper@@GLIBC_2.0
_Z6ConMsgPKcz
iconv_close@@GLIBC_2.1
LOG_GENERAL
atan2@@GLIBC_2.0
fputc@@GLIBC_2.0
dlerror@@GLIBC_2.0
strtok@@GLIBC_2.0
strnlen@@GLIBC_2.0
RandomSeed
vswprintf@@GLIBC_2.2
pthread_cond_wait@@GLIBC_2.3.2
Plat_FloatTime
memmove@@GLIBC_2.0
s_pInterfaceRegs
ThreadSleep
Plat_ExitProcess
towlower@@GLIBC_2.0
_ZTSN9__gnu_cxx26__concurrence_unlock_errorE
send@@GLIBC_2.0
getcwd@@GLIBC_2.0
log@@GLIBC_2.0
sinf@@GLIBC_2.0
puts@@GLIBC_2.0
wcstombs@@GLIBC_2.0
rand@@GLIBC_2.0
sscanf@@GLIBC_2.0
memchr@@GLIBC_2.0
strncmp@@GLIBC_2.0
tan@@GLIBC_2.0
_Z10DevWarningPKcz
dl_iterate_phdr@@GLIBC_2.2.4
Warning
Plat_IsInDebugSession
_edata
snprintf@@GLIBC_2.0
CommandLine
_ZTVN9__gnu_cxx24__concurrence_lock_errorE
sin@@GLIBC_2.0
pthread_cond_broadcast@@GLIBC_2.3.2
tolower@@GLIBC_2.0
_ZTIN9__gnu_cxx24__concurrence_lock_errorE
strcmp@@GLIBC_2.0
towupper@@GLIBC_2.0
__cxa_finalize@@GLIBC_2.1.3
_ZTVN10__cxxabiv120__si_class_type_infoE
pthread_cancel@@GLIBC_2.0
islower@@GLIBC_2.0
logf@@GLIBC_2.0
_ZTSN10__cxxabiv115__forced_unwindE
_init
vscript.so.dbg
