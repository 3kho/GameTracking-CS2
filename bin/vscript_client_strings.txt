__gmon_start__
_init
_fini
__cxa_finalize
_Jv_RegisterClasses
Plat_IsInDebugSession
WriteMiniDump
Plat_ExitProcess
g_pMemAlloc
__gxx_personality_v0
__cxa_call_unexpected
memset
strlen
strcpy
select
_Z6DevMsgPKcz
ThreadSleep
strtoul
_ZNSs6assignEPKcj
_ZNSs6appendEjc
_ZSt18_Rb_tree_incrementPKSt18_Rb_tree_node_base
_ZNSs4_Rep20_S_empty_rep_storageE
_ZNSs4_Rep10_M_destroyERKSaIcE
memmove
_ZSt20__throw_length_errorPKc
tolower
_ZNSsD1Ev
_ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_
_ZNSs6assignERKSs
_ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_
__cxa_begin_catch
__cxa_rethrow
__cxa_end_catch
_ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base
pthread_cancel
socket
listen
accept
__cxa_allocate_exception
__cxa_throw
_ZTVN10__cxxabiv117__class_type_infoE
vsprintf
__cxa_free_exception
memcpy
malloc
_ZTVN10__cxxabiv120__si_class_type_infoE
__expf_finite
__pow_finite
__atan2_finite
atanf
__log10f_finite
__logf_finite
__acosf_finite
__asinf_finite
srand
isalpha
iscntrl
ispunct
isspace
isalnum
isxdigit
islower
isupper
longjmp
isprint
_setjmp
strtok
strchr
strtol
strstr
toupper
strtod
memcmp
__cxa_atexit
strcmp
Plat_FloatTime
Error
Plat_MSTime
RandomInt
Warning
_Z10DevWarningPKcz
strtoll
__cxa_guard_acquire
__cxa_guard_release
RandomFloat
vsnprintf
sscanf
__dynamic_cast
_Z6ConMsgPKcz
_ZTVN10__cxxabiv121__vmi_class_type_infoE
dlopen
dlerror
CommandLine
s_pInterfaceRegs
CreateInterface
dlclose
dlsym
getcwd
strnlen
wcslen
strcasecmp
towupper
towlower
wcsncpy
vswprintf
strncat
wcsncat
mbstowcs
wcstombs
iconv_open
iconv
iconv_close
LOG_GENERAL
LoggingSystem_IsChannelEnabled
LoggingSystem_Log
chdir
iswalnum
iswspace
__atan2f_finite
sincosf
__log_finite
__asin_finite
__acos_finite
GetCPUInformation
RandomSeed
cbrtf
libtier0_client.so
libvstdlib_client.so
libm.so.6
libdl.so.2
libstdc++.so.6
libpthread.so.0
libuuid.so.1
ld-linux.so.2
abort
pthread_once
dl_iterate_phdr
pthread_mutex_lock
pthread_mutex_unlock
libc.so.6
_edata
__bss_start
GLIBC_2.0
GLIBC_2.1
GLIBC_2.15
CXXABI_1.3
GLIBCXX_3.4
GLIBC_2.2.4
GLIBC_2.2
GLIBC_2.1.3
,[^_]
,[^_]
,[^_]
\[^_]
\[^_]
L[^_]
L[^_]
<[^_]
<[^_]
vGf=sr
wvf=so
v|f=di
f=siu
f=tru
<[^_]
<[^_]
,[^_]
\[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
,[^_]
,[^_]
,[^_]
E<3w@
l[^_]
F8+F<
9S vZ
,[^_]
P8+P<
<[^_]
<[^_]
B8+B<
^8+^<9
C8+C<
<[^_]
<[^_]
,[^_]
L[^_]
C8+C<
<[^_]
<[^_]
9XLtK
B8+B<
F8+F<
;x v;
C8+C<
F8+F<
<[^_]
L[^_]
L[^_]
9Z,v+
9x,w)
<[^_]
<[^_]
tg~E=
<[^_]
<[^_]
\[^_]
\[^_]
v,;s0
;{$v<
|[^_]
|[^_]
[,;^0
<[^_]
;~$v;
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
L[^_]
L[^_]
<[^_]
;p v6
<[^_]
;_ v6
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
9^<~p
\[^_]
\[^_]
;K v?
,[^_]
,[^_]
L[^_]
l[^_]
l[^_]
S$9S(
S09S4
,[^_]
,[^_]
,[^_]
,[^_]
R$;V(
l[^_]
@0;F4
@<;F@
V@9VD
<[^_]
<[^_]
,[^_]
<[^_]
<[^_]
<[^_]
\[^_]
L[^_]
\[^_]
\[^_]
{h9{l
~d9N,
~d9N8vH
)th=8
}tL=,
}t==,
)te=8
N@9ND
<[^_]
,[^_]
,[^_]
\[^_]
\[^_]
,[^_]
L[^_]
L[^_]
<[^_]
SX9S\
SL9SPvG
9~@vX
9~LvX
9~pvV
,[^_]
,[^_]
9s4~8
9s<~8
9sD~8
9CL~K
9s$~5
,[^_]
<*t(w
{89{<
{89{<
s89s<
<[^_]
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
{89{<
,[^_]
{89{<
{89{<w
{89{<
<[^_]
<[^_]
s89s<vf
s89s<
s89s<v7
s89s<w
t;9{<w
s89s<
{8;{<
<=tV<>
,[^_]
,[^_]
K09K4w
L[^_]
V,9K4vj
S0f+P,f
|[^_]
;K|v.
<[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
HT~*1
<[^_]
L[^_]
L[^_]
tK~)= 
t>~$= 
,[^_]
,[^_]
<[^_]
<[^_]
,[^_]
,[^_]
9S tX
,[^_]
<[^_]
<[^_]
,[^_]
,[^_]
\[^_]
\[^_]
,[^_]
,[^_]
9{$~Q
,[^_]
;{$}Q
,[^_]
\[^_]
;_8|@
;{(v0
,[^_]
,[^_]
,[^_]
Fl;Fp
9C w/
K,9K0
C,9C0
\[^_]
\[^_]
\[^_]
L[^_]
9S\t3
,[^_]
s 9K4
Cl;Cp
S0f+P,f
,[^_]
;p|v4
\[^_]
,[^_]
,[^_]
tA~G=
,[^_]
,[^_]
,[^_]
<[^_]
L[^_]
<[^_]
<[^_]
<[^_]
,[^_]
9_<~*
L[^_]
L[^_]
<[^_]
<[^_]
<[^_]
<[^_]
<[^_]
,[^_]
u)+C 
,[^_]
,[^_]
,[^_]
It~"1
9^p~,
,[^_]
,[^_]
,[^_]
L[^_]
-VUUU
<[^_]
<[^_]
f;2t{
,[^_]
<[^_]
<[^_]
<[^_]
<[^_]
,[^_]
,[^_]
<[^_]
<[^_]
L[^_]
L[^_]
<[^_]
<[^_]
\[^_]
\[^_]
\[^_]
C$;S(~&
9s0tF
,[^_]
|[^_]
<[^_]
,[^_]
,[^_]
L[^_]
L[^_]
<[^_]
<[^_]
L[^_]
,[^_]
,[^_]
<[^_]
,[^_]
<.t.<\urf
,[^_]
t)<.u
,[^_]
<[^_]
<[^_]
,[^_]
<[^_]
<[^_]
L[^_]
L[^_]
L[^_]
,[^_]
,[^_]
,[^_]
	vI<-tE<_tA<.t=
<[^_]
<[^_]
,[^_]
,[^_]
,[^_]
,[^_]
,[^_]
L[^_]
<[^_]
<[^_]
<[^_]
,[^_]
,[^_]
,[^_]
,[^_]
L[^_]
L[^_]
L[^_]
L[^_]
L[^_]
L[^_]
,[^_]
,[^_]
,[^_]
<[^_]
<[^_]
,[^_]
,[^_]
,[^_]
<[^_]
+C ;C
<[^_]
<[^_]
,[^_]
,[^_]
,[^_]
l[^_]
l[^_]
|[^_]
|[^_]
([^_]
 [^_]
d[^_]
d[^_]
0[^_]
0[^_]
 [^_]
h[^_]
h[^_]
h[^_]
h[^_]
,[^_]
|[^_]
` [^_]
|[^_]
?[^_]
|[^_]
|[^_]
l[^_]
L[^_]
|[^_]
2ZY^_]
,[^_]
Ac@tr
WVSRP
WVSRP
WVSRP
u4PPW
2ZY^_]
,[^_]
~	zuf
vscript
Script debugger disconnected
_sqdbg_debug_hook_
_sqdbg_error_handler_
watches
beginelement
endelement
attribute
vector::_M_default_append
</%s>
terminated
 %s="%s"
break
the breakpoint doesn't exists
removebreakpoint
the watch does not exists
removed watch %d
addbreakpoint
added bp %d %s
error parsing add breakpoint
removed bp %d %s
resumed
go (execution resumed)
suspend
step into
step return
disabled
added watch %d %s
error parsing add watch
added watch %d
error parsing remove watch
terminate from user
ready
unknown packet
&amp;
&apos;
&quot;
&quot;n
&quot;r
error parsing remove breakpoint
failed to bind the socket
disconnected
socket error
SERIALIZE_STATE
error on listen(socket)
error accept(socket)
socket failed
unknown
*FUNCTION [%s] %s line [%d]
AN ERROR HAS OCCURED [%s]
failed to initialize the debugger
error compiling the serialization function
AN ERROR HAS OCCURED [unknown]
	see copyright notice in sqrdbg.h
local currentscope;
if ( ::getroottable().parent )
	currentscope = ::getroottable();
	::setroottable( ::getroottable().parent );
try {
local objs_reg = { maxid=0 ,refs={} }
complex_types <- {
	["table"] = null,
	["array"] = null,
	["class"] = null,
	["instance"] = null,
	["weakref"] = null,
function build_refs(t):(objs_reg)
	if(t == ::getroottable())
		return;
	local otype = ::type(t);
	if(otype in complex_types)
		if(!(t in objs_reg.refs)) {
			objs_reg.refs[t] <- objs_reg.maxid++;
		    iterateobject(t,function(o,i,val):(objs_reg)
		    {
			    build_refs(val);
			    build_refs(i);
		    })
function getvalue(v):(objs_reg)
	switch(::type(v))
		case "table":
		case "array":
		case "class":
		case "instance":
			return objs_reg.refs[v].tostring();
		case "integer":
		case "float":
		    return v;
		case "bool":
		    return v.tostring();
		case "string":
			return v;
		case "null":
		    return "null";
		default:
			return pack_type(::type(v));
local packed_types={
	["null"]="n",
	["string"]="s",
	["integer"]="i",
	["float"]="f",
	["userdata"]="u",
	["function"]="fn",
	["table"]="t",
	["array"]="a",
	["generator"]="g",
	["thread"]="h",
	["instance"]="x", 
	["class"]="y",  
	["bool"]="b",
	["weakref"]="w"  
function pack_type(type):(packed_types)
	if(type in packed_types)return packed_types[type]
	return type
function iterateobject(obj,func)
	local ty = ::type(obj);
	if(ty == "instance") {
		try { //TRY TO USE _nexti
		    foreach(idx,val in obj)
		    {
				func(obj,idx,val);
		    }
		catch(e) {
		   foreach(idx,val in obj.getclass())
		   {
			func(obj,idx,obj[idx]);
		   }
	else if(ty == "weakref") {
		func(obj,"@ref",obj.ref());
	else {
		foreach(idx,val in obj)
		    func(obj,idx,val);
function build_tree():(objs_reg)
	foreach(i,o in objs_reg.refs)
		beginelement("o");
		attribute("type",(i==::getroottable()?"r":pack_type(::type(i))));
		local _typeof = typeof i;
		if(_typeof != ::type(i)) {
			attribute("typeof",_typeof);
		attribute("ref",o.tostring());
		if(i != ::getroottable()){
			iterateobject(i,function (obj,idx,val) {
				if(::type(val) == "function")
					return;
					
				if ( ::type(idx) == "string" && idx.find( "__" ) == 0 )
					return;
				beginelement("e");	
					emitvalue("kt","kv",idx);
					emitvalue("vt","v",obj[idx]);
				endelement("e");	
			})
		endelement("o");
function evaluate_watch(locals,id,expression)
	local func_src="return function ("
	local params=[];
	params.append(locals["this"])
	local first=1;
	foreach(i,v in locals){
		if(i!="this" && i[0] != '@'){ //foreach iterators start with @
			if(!first){
				func_src=func_src+","
			first=null
			params.append(v)
			func_src=func_src+i
	func_src=func_src+"){\n"
	func_src=func_src+"return ("+expression+")\n}"
	try {
		local func=::compilestring(func_src);
		return {status="ok" , val=func().acall(params)};
	catch(e)
		return {status="error"}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
function emitvalue(type_attrib,value_attrib,val)
	attribute(type_attrib,pack_type(::type(val)));
	attribute(value_attrib,getvalue(val).tostring());
local stack=[]
local level=3;
local si;
	//ENUMERATE THE STACK WATCHES
	while(si=::getstackinfos(level))
		stack.append(si);
		level++;
	//EVALUATE ALL WATCHES
	objs_reg.refs[::getroottable()] <- objs_reg.maxid++;
	foreach(i,val in stack)
		if(val.src!="NATIVE") {
			if("watches" in this) {
				val.watches <- {}
				foreach(i,watch in watches)
				{
					if(val.src!="NATIVE"){
						val.watches[i] <- evaluate_watch(val.locals,i,watch);
						if(val.watches[i].status!="error")
							build_refs(val.watches[i].val);
					}
					else{
						val.watches[i] <- {status="error"}
					}
					val.watches[i].exp <- watch;
				}
		foreach(i,l in val.locals)
			build_refs(l);
	beginelement("objs");
	build_tree();
	endelement("objs");
	beginelement("calls");
	foreach(i,val in stack)
		beginelement("call");
		attribute("fnc",val.func);
		attribute("src",val.src);
		attribute("line",val.line.tostring());
		foreach(i,v in val.locals)
			beginelement("l");
				attribute("name",getvalue(i).tostring());
				emitvalue("type","val",v);
			endelement("l");
		if("watches" in val) {
			foreach(i,v in val.watches)
				beginelement("w");
					attribute("id",i.tostring());
					attribute("exp",v.exp);
					attribute("status",v.status);
					if(v.status!="error") {
						emitvalue("type","val",v.val);
					}
				endelement("w");
		endelement("call");
	endelement("calls");
	objs_reg = null;
	stack = null;
	if("collectgarbage" in ::getroottable()) ::collectgarbage();
}catch(e)
	::print("ERROR"+e+"\n");
if ( currentscope )
	::setroottable( currentscope );
getVar(): Could not create instance: %s
getVar(): Invalid type+access: 'ScriptStringVarBase' with VAR_ACCESS_CONSTANT (use VAR_ACCESS_READ_ONLY instead)
getVar(): Invalid type+access: 'const SQChar *' without VAR_ACCESS_CONSTANT
getVarInfo: Could not retrieve UserData
getInstanceVarInfo: Could not retrieve UserData
setVar(): Cannot write to constant: %s
INSTANCE type assignment mismatch
setVar(): Cannot write to an SQUserPointer: %s
Invalid Instance Type
constructor
13SquirrelError
__SqTypes
14SquirrelObject
unknown error
call already initialized
call not initialized
t|y|x%s
t|y|x
CreateFunction: typeMask string too long.
%s line = (%d) column = (%d) : error %s
*FUNCTION [%s()] %s line [%d]
AN ERROR HAS OCCURED [unknown]
false
CALLSTACK
LOCALS
[%s] NULL
[%s] %d
[%s] %.14g
[%s] USERPOINTER
[%s] "%s"
[%s] TABLE
[%s] ARRAY
[%s] CLOSURE
[%s] NATIVECLOSURE
[%s] GENERATOR
[%s] USERDATA
[%s] THREAD
[%s] CLASS
[%s] INSTANCE
[%s] WEAKREF
[%s] %s
internal error (_nexti) wrong argument type
cannot create blob with negative size
resize failed
std_blob
resize
swap2
swap4
_typeof
_nexti
casti2f
castf2i
swapfloat
8SQStream
6SQBlob
invalid param
RAND_MAX
log10
atan2
floor
srand
overflow in numeric constant
letter expected
expected paren
empty class
invalid range
, or } expected
unexpected character
cannot use character classes in ranges
invalid type tag
the stream is invalid
invalid origin
invalid format
invalid parameter
io error
no data left to read
std_stream
table expected
readblob
readn
writeblob
writen
flush
regexp
empty separators string
begin
-+ #0
width format too long
precision format too long
search
match
capture
subexpcount
lstrip
rstrip
split
not enough paramters for the given format string
string expected for the specified format
integer expected for the specified format
float expected for the specified format
wrong argument type, expected '%s' got '%.50s'
not enough params in the stack
rawset works only on array/table/class and instance
the object is not a class instance
the object is not a nativeclosure
rawget works only on array/table/instance and class
clear only works on table and array
only generators can be resumed
cannot resume a vm that is not running any code
the type doesn't have a default delegate
the index doesn't exist
wrong type
null key
null is not a valid key
the object is not a class
the class is locked
invalid object type
ivalid type, expected table
ivalid type
invalid param type
invalid base type
unexpected type %s
delagate cycle
the object is not a closure
negative size
invalid stream
invalid free var index
wrong index
the object must be a weakref
cannot iterate a generator
the target is not a closure
invalid environment
native closure expected
invalid typemask
13SQCollectable
unnamedbuffer
locals
running
suspended
internal VM error
assertion failed
top() on a empty array
cannot wakeup a idle thread
wrong parameter
wrong indexes
slice out of range
size must be a number
idx out of range
cannot convert the string
seterrorhandler
_version_
Squirrel 2.2.3 stable
_charsize_
_intsize_
_floatsize_
compare func failed
native
varargs
paramscheck
typecheck
getclass
rawin
getattributes
setattributes
wakeup
getstatus
pcall
pacall
bindenv
c x|y|t
getinfos
tointeger
tofloat
tochar
slice
 s n  n
s s n 
tolower
toupper
extend
insert
remove
reverse
clear
rawget
rawset
rawdelete
setdebughook
enabledebuginfo
getstackinfos
getroottable
setroottable
getconsttable
setconsttable
assert
print
compilestring
newthread
dummy
collectgarbage
cannot wakeup a running thread
Invalid qsort, probably compare function defect
7SQClass
10SQInstance
IDENTIFIER
STRING_LITERAL
INTEGER
FLOAT
expected '%s'
expected '%c'
expected ')'
expected '='
expected ')' or ','
invalid constant [%s.%s]
expression expected
parent cannot be set
can't delete an expression
cannot delete a local
can't assign expression
can't 'create' a local slot
invalid class name
@INDEX@
@ITERATOR@
scalar expected : integer,float
scalar expected : integer,float or string
function with default parameters cannot have variable number of parameters
cannot brake deref/or comma needed after [exp]=exp slot declaration
expression expected, found ')'
free variables cannot be modified
'break' has to be in a loop block
'continue' has to be in a loop block
cannot create a class in a local with the syntax(class <local>)
end of statement expected (; or lf)
NATIVE
%.14g
the index '%.50s' does not exist
comparsion between '%.50s' and '%.50s'
parameter %d has an invalid type '%s' ; expected: '%s'
(%s %p)
internal compiler error: too many locals
15SQFunctionProto
Invalid character
while
continue
foreach
catch
throw
clone
yield
resume
switch
default
parent
extends
instanceof
vargc
vargv
static
const
missing "*/" in comment
unfinished string
newline in a constant
hexadecimal number expected
unrecognised escaper char
empty constant
constant too long
invalid octal number
invalid numeric format
exponent expected
string expected
error parsing the string
invalid token '..'
unexpected character(control)
too many digits for an Hex number
_delegate 
native function
userdata
resuming dead generator
resuming active generator
cannot serialize a %s
_lasterror
_errorhandler
_debughook
_roottable
temp_reg
_stack
_vargsstack
_members
_base 
_attributes
_defaultvalues
_methods
_metamethods
_class 
internal vm error, yielding dead generator
internal vm error, yielding a dead generator
io error (write function failure)
io error, read function failure, the origin stream could be corrupted/trucated
invalid or corrupted closure stream
12SQRefCounted
9SQWeakRef
11SQDelegable
8SQString
7SQArray
10SQUserData
9SQClosure
11SQGenerator
15SQNativeClosure
_registry
_consts
_metamethodsmap
_table_default_delegate
_array_default_delegate
_string_default_delegate
_number_default_delegate
_generator_default_delegate
_thread_default_delegate
_closure_default_delegate
_class_default_delegate
_instance_default_delegate
_weakref_default_delegate
userpointer
_modulo
_call
_cloned
_newslot
_delslot
_tostring
_newmember
_inherited
7SQTable
internal vm error bitwise op failed
bitwise op between '%s' and '%s'
cannot suspend an already suspended vm
cannot suspend through native calls/metamethods
the function doesn't have var args
the %s type doesn't have a parent slot
Script terminated by SQQuerySuspend
cannot apply instanceof between a %s and a %s
attempt to perform a bitwise op on a %s
trying to yield a '%s',only genenerator can be yielded
trying to resume a '%s',only genenerator can be resumed
attempt to delete a slot from a %s
class instances do not support the new slot operator
trying to modify a class that has already been instantiated
the property '%s' already exists
_nexti returned an invalid idx
arith op %c on between '%s' and '%s' (%s)
arith op %c on between '%s' and '%s'
delegating a '%s'
delegate cycle detected
using '%s' as delegate
indexing 'vargv' with %s
vargv index out of range
Native stack overflow
wrong number of parameters
terminated by debugger
attempt to call '%s'
cloning a %s
cannot delete a slot from %s
null cannot be used as index
indexing %s with %s
trying to set '%s'
_nexti failed
cannot iterate %s
(weakref : 0x%p [%s] )
(%s : 0x%p)
attempt to negate a %s
division by zero
modulo by zero
trying to inherit from a %s
4SQVM
pABOOL
TABLE
ARRAY
NATIVECLOSURE
USERDATA
GENERATOR
THREAD
USERPOINTER
CLASS
INSTANCE
WEAKREF
<unknown>
Squirrel
unnamed
%x%x%llx_%s
function 
<unnamed>
Vector
null vector
Internal error
RegisterFunctionDocumentation
%s [%d]
(instance : 0x%p)
%f %f %f))
(vector : (%f, %f, %f))
Vector argument expected
Accessed null instance
CUtlFixedMemory overflow!
developer
IsValid
CUtlRBTree overflow!
Incompatible script version
GetFunctionSignature
VSquirrel_OnCreateScope
VSquirrel_OnReleaseScope
ToKVString
Length
LengthSqr
Length2D
Length2DSqr
Cross
handle
Script running too long, terminating
GenerateUniqueKey: buffer too small
NULL instance passed to vscript!
Invalid scope handed to script VM
Callstack mismatch in VScript/Squirrel!
FmtStrVSNPrintf truncated to %d without QUIET_TRUNCATION specified!
CUtlLinkedList overflow! (exhausted index range)
CUtlLinkedList overflow! (exhausted memory allocator)
Save load of generators not well tested. caveat emptor
Failed to restore a Squirrel object of type %s
Failed to read Squirrel table entry %s
23CSplitScreenAddedConVar
8CFmtStrNILi256ELb0EE
9IScriptVM
11CSquirrelVM
ZN11CSquirrelVM9DumpStateEvE9CIterator
16CSQStateIterator
?Generate a random floating point number within a range, inclusive
Generate a random integer within a range, inclusive
RandomFloat
RandomInt
VScriptManager009
14CScriptManager
15CTier1AppSystemI14IScriptManagerLi0EE
15CTier0AppSystemI14IScriptManagerE
14CBaseAppSystemI14IScriptManagerE
14IScriptManager
10IAppSystem
{}()':
%i %i %i %i
FCVAR_NEVER_AS_STRING
"%s" = "%s"
 ( def. "%s" )
 min. %f
 max. %f
"%s" 
%-80s - %.80s
%-80s
client
archive
notify
singleplayer
notconnected
cheat
replicated
server_can_execute
clientcmd_can_execute
ss_added
CCommand::Tokenize: Encountered command which overflows the tokenizer buffer.. Skipping!
CCommand::Tokenize: Encountered command which overflows the argument buffer.. Clamped!
Warning:  %s = '%s' is infinite, clamping value.
ConVarRef %s doesn't point to an existing ConVar
 [%.3f server clamped to %.3f]
ConVar(%s) defined with infinite float value (%s)
InstallChangeCallback called with NULL callback, ignoring!!!
InstallChangeCallback ignoring duplicate change callback!!!
14ConCommandBase
10ConCommand
6ConVar
20ConVar_ServerBounded
7IConVar
12CEmptyConVar
16CDefaultAccessor
23IConCommandBaseAccessor
?_client.so
No such file
image not found
_xlsp
_valveinternal
-xlsp
-valveinternal
DLOPEN Error:%s
%s/%s
%s/bin/%s
BuiltDebug
-allowdebug
Module %s is a debug build
CreateInterface
 failed to dlopen %s error=%s
16CDllDemandLoader
 bytes
%%.%if%s
,%03d
UCS-2LE
UCS-4LE
UTF-32LE
UTF-8
0123456789ABCDEF
%s %s %s %s
V_AppendSlash: ran out of space on %s.
V_MakeAbsolutePath: _getcwd failed.
V_MakeAbsolutePath: tried to ".." past the root.
0123456789ABCDEF
0123456789abcdef
CUtlBuffer::VaPrintf: String overflowed buffer [%d]
18CUtlCharConversion
21CUtlCStringConversion
19CUtlNoEscConversion
APPSYSTEM: In ConnectInterfaces(), s_nRegistrationCount is %d!
Physics2 Interface ActorMgr v0.1
Physics2 Interface ResourceMgr v0.1
MaterialSystemHardwareConfig013
VEngineCvar007
EventSystem001
VProcessUtils002
Physics2 Interface v0.3
VFileSystem017
VNewAsyncFileSystem001
ResourceSystem004
VMaterialSystem080
VMaterialSystem2_001
InputSystemVersion001
InputStackSystemVersion001
NetworkSystemVersion001
RenderDeviceMgr001
SoundSystem001
DebugTextureInfo001
VBAllocTracker001
COLORCORRECTION_VERSION_1
VP4002
VMDLLIB001
QueuedLoaderVersion001
VResourceAccessControl001
VPrecacheSystem001
VStudioRender026
VGUI_ivgui008
VGUI_Input005
VGUI_Panel009
VGUI_Surface031
VGUI_Scheme010
VGUI_System010
Localize_001
MatSystemSurface006
VDataCache003
MDLCache004
VAvi001
VBik001
VDmeMakeFileUtils001
VPhysicsCollision007
VSoundEmitter003
MeshSystem001
RenderDevice001
RenderHardwareConfig001
SceneSystem_001
WorldRendererMgr001
RenderSystemSurface001
MATCHFRAMEWORK_001
GameUISystemMgr001
SSE and SSE2 are required.
'_? A1> A1> A1> A1>
4fff>fff>fff>fff>
?333333
C33s?
;*2$"
B. I.
B. E.
B. E.
B. E.
//===	======= Copyright 
 2008, Valve Corporation, All rights reserved. ========
// Purpose: Script initially run after squirrel VM is initialized
//=============================================================================
//-----------------------------------------------------------------------------
// General
//-----------------------------------------------------------------------------
function printl( text )
	return print( text + "\n" );
function Msg( text )
	return print( text );
function Assert( b, msg = null )
	if ( b )
		return;
	if ( msg != null )
		throw "Assertion failed: " + msg;
	else
		throw "Assertion failed";
//-----------------------------------------------------------------------------
// Documentation table
//-----------------------------------------------------------------------------
if ( developer() > 0 )
	Documentation <-
		classes = {}
		functions = {}
		instances = {}
	function RetrieveNativeSignature( nativeFunction )
		if ( nativeFunction in NativeFunctionSignatures )
			return NativeFunctionSignatures[nativeFunction]
		return "<unnamed>"
	function RegisterFunctionDocumentation( func, name, signature, description )
		if ( description.len() )
			local b = ( description[0] == '#' );
			if ( description[0] == '#' )
				local colon = description.find( ":" );
				if ( colon == null )
				{
					colon = description.len();
				}
				local alias = description.slice( 1, colon );
				description = description.slice( colon + 1 );
				name = alias;
				signature = "#";
		Documentation.functions[name] <- [ signature, description ]
	function Document( symbolOrTable, itemIfSymbol = null, descriptionIfSymbol = null )
		if ( typeof( symbolOrTable ) == "table" )
			foreach( symbol, itemDescription in symbolOrTable )
				Assert( typeof(symbol) == "string" )
				Document( symbol, itemDescription[0], itemDescription[1] );
		else
			printl( symbolOrTable + ":" + itemIfSymbol.tostring() + "/" + descriptionIfSymbol );
	function PrintHelp( string = "*", exact = false )
		local matches = []
		if ( string == "*" || !exact )
			foreach( name, documentation in Documentation.functions )
				if ( string != "*" && name.tolower().find( string.tolower() ) == null )
				{
					continue;
				}
				matches.append( name ); 
		else if ( exact )
			if ( string in Documentation.functions )
				matches.append( string )
		if ( matches.len() == 0 )
			printl( "Symbol " + string + " not found" );
			return;
		matches.sort();
		foreach( name in matches )
			local result = name;
			local documentation = Documentation.functions[name];
			printl( "Function:    " + name );
			local signature;
			if ( documentation[0] != "#" )
				signature = documentation[0];
			else
				signature = GetFunctionSignature( this[name], name );
			printl( "Signature:   " + signature );
			if ( documentation[1].len() )
				printl( "Description: " + documentation[1] );
			print( "\n" ); 
	function RetrieveNativeSignature( nativeFunction ) { return "<unnamed>"; }
	function Document( symbolOrTable, itemIfSymbol = null, descriptionIfSymbol = null ) {}
	function PrintHelp( string = "*", exact = false ) {}
//-----------------------------------------------------------------------------
// VSquirrel support functions
//-----------------------------------------------------------------------------
function VSquirrel_OnCreateScope( name, outer )
	local result;
	if ( !(name in outer) )
		result = outer[name] <- { __vname=name, __vrefs = 1 };
		delegate outer : result;
	else
		result = outer[name];
		result.(void, long double,...)(float, short) += 1;
	return result;
function VSquirrel_OnReleaseScope( scope )
	scope.(void, long double,...)(float, short) -= 1;
	if ( scope.(void, long double,...)(float, short) < 0 )
		throw "Bad reference counting on scope " + scope.__vname;
	else if ( scope.(void, long double,...)(float, short) == 0 )
		delete scope.parent[scope.__vname];
		scope.__vname = null;
		delegate null : scope;
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
class CCallChainer
	constructor( prefixString, scopeForThis = null )
		prefix = prefixString;
		if ( scopeForThis != null )
			scope = scopeForThis;
		else
			scope = ::getroottable();
		chains = {};
		// Expose a bound global function to dispatch to this object
		scope[ "Dispatch" + prefixString ] <- Call.bindenv( this );
	function PostScriptExecute() 
		foreach( key, value in scope )
			if ( typeof( value ) == "function" ) 
				if ( key.find( prefix ) == 0 )
				{
					key = key.slice( prefix.len() );
					
					if ( !(key in chains) )
					{
						//::print( "Creating new call chain " + key + "\n");
						chains[key] <- [];
					}
					
					local chain = chains[key];
					
					if ( !chain.len() || chain.top() != value )
					{
						chain.push( value );
						//::print( "Added " + value + " to call chain " + key + "\n" );
					}
				}
	function Call( event, ... )
		if ( event in chains )
			local chain = chains[event];
			if ( chain.len() )
				local i;
				local args = [];
				if ( vargc > 0 )
				{
					args.push( scope );
					for ( i = 0; i < vargc; i++ )
					{
						args.push( vargv[i] );
					}
				}
				for ( i = chain.len() - 1; i >= 0; i -= 1 )
				{
					local func = chain[i];
					local result;
					if ( !args.len() )
					{
						result = func();
					}
					else
					{
						result = func.acall( args ); 
					}
					if ( result != null && !result )
						return false;
				}
		return true;
	scope = null;
	prefix = null;
	chains = null;
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
class CSimpleCallChainer
	constructor( prefixString, scopeForThis = null, exactNameMatch = false )
		prefix = prefixString;
		if ( scopeForThis != null )
			scope = scopeForThis;
		else
			scope = ::getroottable();
		chain = [];
		// Expose a bound global function to dispatch to this object
		scope[ "Dispatch" + prefixString ] <- Call.bindenv( this );
		exactMatch = exactNameMatch
	function PostScriptExecute() 
		foreach( key, value in scope )
			if ( typeof( value ) == "function" ) 
				local foundMatch = false;
				if ( exactMatch )
				{
					foundMatch = ( prefix == key );
				}
				else
				{
					foundMatch = ( key.find( prefix ) == 0 )
				}
						
				if ( foundMatch )
				{
					if ( !exactMatch )
						key = key.slice( prefix.len() );
					
					if ( !(chain) )
					{
						//::print( "Creating new call simple chain\n");
						chain <- [];
					}
					
					if ( !chain.len() || chain != value )
					{
						chain.push( value );
						//::print( "Added " + value + " to call chain.\n" );
					}
				}
	function Call( ... )
		if ( chain.len() )
			local i;
			local args = [];
			if ( vargc > 0 )
				args.push( scope );
				for ( i = 0; i < vargc; i++ )
				{
					args.push( vargv[i] );
				}
			for ( i = chain.len() - 1; i >= 0; i -= 1 )
				local func = chain[i];
				local result;
				if ( !args.len() )
				{
					result = func.pcall( scope );
				}
				else
				{
					result = func.pacall( scope, args ); 
				}
				if ( result != null && !result )
					return false;
		return true;
	exactMatch = false
	scope = null;
	prefix = null;
	chain = null;
//-----------------------------------------------------------------------------
// Late binding: allows a table to refer to parts of itself, it's children,
// it's owner, and then have the references fixed up after it's fully parsed
// Usage:
//    lateBinder <- LateBinder();
//    lateBinder.Begin( this );
//    
//    Test1 <-
//    {   
// 	   Foo=1
//    }   
//    
//    Test2 <-
//    {   
// 	   FooFoo = "I'm foo foo"
// 	   BarBar="@Test1.Foo"
// 	   SubTable = { boo=[bah, "@Test2.FooFoo", "@Test1.Foo"], booboo2={one=bah, two="@Test2.FooFoo", three="@Test1.Foo"} }
// 	   booboo=[bah, "@Test2.FooFoo", "@Test1.Foo"]
// 	   booboo2={one=bah, two="@Test2.FooFoo", three="@Test1.Foo"}
// 	   bah=wha
//    }   
//    
//    lateBinder.End();
//    delete lateBinder;
// When End() is called, all of the unresolved symbols in the tables and arrays will be resolved,
// any left unresolved will become a string prepended with '~', which later code can deal with
//-----------------------------------------------------------------------------
class LateBinder
	// public:
	function Begin( target, log = false )
		m_log = log;
		HookRootMetamethod( "_get", function( key ) { return "^" + key; } );
		HookRootMetamethod( "_newslot", function( key, value ) { if ( typeof value == "table" ) { m_fixupSet.push( [ key, value ] ); this.rawset( key, value ); };  }.bindenv(this) );
		m_targetTable = target;
		Log( "Begin late bind on table " + m_targetTable );
	function End()
		UnhookRootMetamethod( "_get" );
		UnhookRootMetamethod( "_newslot" );
		Log( "End late bind on table " + m_targetTable );
		foreach( subTablePair in m_fixupSet )
			EstablishDelegation( m_targetTable, subTablePair[1] );
		Log( "Begin resolution... " )
		m_logIndent++;
		local found = true;
		while ( found )
			foreach( subTablePair in m_fixupSet )
				Log( subTablePair[0] + " = " );
				Log( "{" );
				if ( !Resolve( subTablePair[1], subTablePair[1], false ) )
				{
					found = false;
				}
				Log( "}" );
		m_logIndent--;
		foreach( subTablePair in m_fixupSet )
			RemoveDelegation( subTablePair[1] );
		Log( "...end resolution" );
	// private:
	function HookRootMetamethod( name, value )
		local saved = null;
		local roottable = getroottable();
		if ( name in roottable )
			saved = roottable[name];
		roottable[name] <- value;
		roottable["__saved" + name] <- saved;
	function UnhookRootMetamethod( name )
		local saveSlot = "__saved" + name;
		local roottable = getroottable();
		local saved = roottable[saveSlot];
		if ( saved != null )
			roottable[name] = saved;
		else
			delete roottable[name];
		delete roottable[saveSlot];
	function EstablishDelegation( parentTable, childTable )
		delegate parentTable : childTable;
		foreach( key, value in childTable )
			local type = typeof value;
			if ( type == "table" )
				EstablishDelegation( childTable, value );
	function RemoveDelegation( childTable )
		delegate null : childTable;
		foreach( key, value in childTable )
			local type = typeof value;
			if ( type == "table" )
				RemoveDelegation( value );
	function Resolve( lookupTable, subTableOrArray, throwException = false )
		m_logIndent++;
		local found = false;
		foreach( key, value in subTableOrArray )
			local type = typeof value;
			if ( type == "string" )
				if ( value.len() )
				{
					local unresolvedId = null;
					local controlChar = value[0]
					if ( controlChar == '^' )
					{
						found = true;
						value = value.slice( 1 );
						if ( value in lookupTable )
						{
							subTableOrArray[key] = lookupTable[value];
							Log( key + " = " + lookupTable[value] + " <-- " + value );
						}
						else
						{
							subTableOrArray[key] = "~" + value;
							unresolvedId = value;
							Log( key + " = \"" + "~" + value + "\" (unresolved)" );
						}
					}
					else if ( controlChar == '@' )
					{
						found = true;
						local identifiers = [];
						local iLast = 1;
						local iNext;
						while ( ( iNext = value.find( ".", iLast ) ) != null )
						{
							identifiers.push( value.slice( iLast, iNext ) );
							iLast = iNext + 1;
						}
						identifiers.push( value.slice( iLast ) );
						
						local depthSuccess = 0;
						local result = lookupTable;
						foreach( identifier in identifiers )
						{
							if ( identifier in result )
							{
								depthSuccess++;
								result = result[identifier];
							}
							else
							{
								break;
							}
						}
						if ( depthSuccess == identifiers.len() )
						{
							subTableOrArray[key] = result;
							Log( key + " = " + result + " <-- " + value );
						}
						else
						{
							subTableOrArray[key] = "~" + value.slice( 1 );
							unresolvedId = value;
							Log( key + " = \"" + "~" + value + "\" (unresolved)" );
						}
					}
					
					if ( unresolvedId != null )
					{
						if ( throwException )
						{
							local exception = "Unresolved symbol: " + bind + " in ";
							foreach ( entry in m_bindNamesStack )
							{
								exception += entry;
								exception += "."
							}
							exception += unresolvedId;
							
							throw exception; 
						}
					}
				}
		foreach( key, value in subTableOrArray )
			local type = typeof value;
			local isTable = ( type == "table" );
			local isArray = ( type == "array" )
			if ( isTable || isArray )
				Log( key + " =" );
				Log( isTable ? "{" : "[" );
				m_bindNamesStack.push( key );
				if ( Resolve( ( isTable ) ? value : lookupTable, value, throwException ) )
				{
					found = true;
				}
				m_bindNamesStack.pop();
				Log( isTable ? "}" : "]" );
		m_logIndent--;
		return found;
	function Log( string )
		if ( m_log )
			for ( local i = 0; i < m_logIndent; i++ )
				print( "  " );
			printl( string );
	m_targetTable = null;
	m_fixupSet = [];
	m_bindNamesStack = [];
	m_log = false;
	m_logIndent = 0;
r""\\
GCC: (crosstool-NG 1.17.0) 4.6.3
vscript_client.so.dbg
.symtab
.strtab
.shstrtab
.note.gnu.build-id
.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rel.dyn
.rel.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.ctors
.dtors
.dynamic
.got.plt
.data
.comment
.gnu_debuglink
abort@@GLIBC_2.0
pthread_once@@GLIBC_2.0
_ZSt20__throw_length_errorPKc@@GLIBCXX_3.4
sprintf@@GLIBC_2.0
srand@@GLIBC_2.0
__acosf_finite@@GLIBC_2.15
isprint@@GLIBC_2.0
__log_finite@@GLIBC_2.15
isalpha@@GLIBC_2.0
RandomFloat
__cxa_atexit@@GLIBC_2.1.3
tanf@@GLIBC_2.0
memcmp@@GLIBC_2.0
wcsncat@@GLIBC_2.0
__cxa_guard_acquire@@CXXABI_1.3
__gmon_start__
_Jv_RegisterClasses
ispunct@@GLIBC_2.0
iconv_open@@GLIBC_2.1
isspace@@GLIBC_2.0
vsprintf@@GLIBC_2.0
__atan2f_finite@@GLIBC_2.15
strtod@@GLIBC_2.0
strchr@@GLIBC_2.0
vsnprintf@@GLIBC_2.0
Plat_MSTime
recv@@GLIBC_2.0
_fini
__log10f_finite@@GLIBC_2.15
__cxa_rethrow@@CXXABI_1.3
wcslen@@GLIBC_2.0
listen@@GLIBC_2.0
LoggingSystem_Log
dlclose@@GLIBC_2.0
toupper@@GLIBC_2.0
memset@@GLIBC_2.0
_ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base@@GLIBCXX_3.4
isxdigit@@GLIBC_2.0
sincosf@@GLIBC_2.1
RandomInt
iscntrl@@GLIBC_2.0
CreateInterface
strtoll@@GLIBC_2.0
strtol@@GLIBC_2.0
_ZNSsD1Ev@@GLIBCXX_3.4
free@@GLIBC_2.0
_Z6DevMsgPKcz
atan@@GLIBC_2.0
cbrtf@@GLIBC_2.0
__atan2_finite@@GLIBC_2.15
atanf@@GLIBC_2.0
_ZNSs4_Rep10_M_destroyERKSaIcE@@GLIBCXX_3.4
WriteMiniDump
dlsym@@GLIBC_2.0
accept@@GLIBC_2.0
socket@@GLIBC_2.0
GetCPUInformation
pthread_mutex_unlock@@GLIBC_2.0
LoggingSystem_IsChannelEnabled
_ZTVN10__cxxabiv117__class_type_infoE@@CXXABI_1.3
mbstowcs@@GLIBC_2.0
__cxa_guard_release@@CXXABI_1.3
_ZNSs6appendEjc@@GLIBCXX_3.4
_setjmp@@GLIBC_2.0
g_pMemAlloc
memcpy@@GLIBC_2.0
_ZSt18_Rb_tree_incrementPKSt18_Rb_tree_node_base@@GLIBCXX_3.4
Error
strtoul@@GLIBC_2.0
strlen@@GLIBC_2.0
cosf@@GLIBC_2.0
cos@@GLIBC_2.0
iconv@@GLIBC_2.1
__cxa_call_unexpected@@CXXABI_1.3
strcpy@@GLIBC_2.0
__dynamic_cast@@CXXABI_1.3
dlopen@@GLIBC_2.1
longjmp@@GLIBC_2.0
printf@@GLIBC_2.0
chdir@@GLIBC_2.0
bind@@GLIBC_2.0
__pow_finite@@GLIBC_2.15
wcsncpy@@GLIBC_2.0
iswspace@@GLIBC_2.0
strcasecmp@@GLIBC_2.0
select@@GLIBC_2.0
close@@GLIBC_2.0
isalnum@@GLIBC_2.0
strstr@@GLIBC_2.0
strncat@@GLIBC_2.0
__bss_start
_ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_@@GLIBCXX_3.4
malloc@@GLIBC_2.0
pthread_mutex_lock@@GLIBC_2.0
iswalnum@@GLIBC_2.0
_ZTVN10__cxxabiv120__si_class_type_infoE@@CXXABI_1.3
__asinf_finite@@GLIBC_2.15
isupper@@GLIBC_2.0
_Z6ConMsgPKcz
iconv_close@@GLIBC_2.1
LOG_GENERAL
_ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_@@GLIBCXX_3.4
__cxa_allocate_exception@@CXXABI_1.3
dlerror@@GLIBC_2.0
strtok@@GLIBC_2.0
strnlen@@GLIBC_2.0
__cxa_free_exception@@CXXABI_1.3
_ZNSs6assignERKSs@@GLIBCXX_3.4
RandomSeed
vswprintf@@GLIBC_2.2
_ZNSs6assignEPKcj@@GLIBCXX_3.4
Plat_FloatTime
memmove@@GLIBC_2.0
s_pInterfaceRegs
ThreadSleep
_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3
Plat_ExitProcess
towlower@@GLIBC_2.0
send@@GLIBC_2.0
getcwd@@GLIBC_2.0
__cxa_throw@@CXXABI_1.3
sinf@@GLIBC_2.0
puts@@GLIBC_2.0
__expf_finite@@GLIBC_2.15
wcstombs@@GLIBC_2.0
__cxa_end_catch@@CXXABI_1.3
rand@@GLIBC_2.0
sscanf@@GLIBC_2.0
_ZNSs4_Rep20_S_empty_rep_storageE@@GLIBCXX_3.4
__cxa_begin_catch@@CXXABI_1.3
tan@@GLIBC_2.0
_Z10DevWarningPKcz
dl_iterate_phdr@@GLIBC_2.2.4
Warning
Plat_IsInDebugSession
_edata
snprintf@@GLIBC_2.0
CommandLine
__gxx_personality_v0@@CXXABI_1.3
sin@@GLIBC_2.0
tolower@@GLIBC_2.0
strcmp@@GLIBC_2.0
__logf_finite@@GLIBC_2.15
towupper@@GLIBC_2.0
__cxa_finalize@@GLIBC_2.1.3
pthread_cancel@@GLIBC_2.0
islower@@GLIBC_2.0
__acos_finite@@GLIBC_2.15
_init
__asin_finite@@GLIBC_2.15
